Data Access-aware BalLooning

Basic idea: Replace compaction with isolation

isolation/report
reclamation
hot-remove

hot-unremove
stop-reclamation
unisolation

Isolation is better than reclamation.

Usable memory: memory that usable by users (except isolated memory and
allocated memory)
Free memory: free memory
Free memory ratio: Free memory / Usable memory

1. If the free memory ratio is more than 50% and the free memory is more than 2
memory blocks size, start access-aware isolation of the last online block.
2. If isolation results in free memory ratio less than 30% or less than 2
   memory blocks, stop isolation, start DARC and unisolation.

while True:
	if free_mem_ratio > 0.5 and freem_mem_bytes > 2 * sz_memblock:
		stop_periodic_unisolation(last_online_block)
		stop_proactive_reclamation()
		start_access_aware_isolation(last_online_block)
	if entire_isolated(last_oneline_block)
		hot_remove(last_online_block)
	if free_mem_ratio < 0.3 or free_mem_bytes < 1.5 * sz_memblock:
		stop_access_aware_isolation(last_online_block)
		start_periodic_unisolation(last_online_block)
		start_proactive_reclamation()
		if entire_unisolated(last_oneline_block):
			hot-add(last_hotremoved_block)
			last_online_block = last_hotremoved_block
			last_hotremoved_block = min(last_online_block + 1, last_block)

3. 

1. If free memory ratio is less than 30%, run DARC until it be 50%.
2. If free memory ratio is more than 50% and free memory is more than 2 memory
blocks size, set the last memory block as hot-remove target.
2-1. Isolate memory in the hot-remove target block in 2MiB granularity, cold
2MiB contig pages first (use DAMOS).  Report isolated memory to the host as
free.
2-2. If all memory of the block is isolated, hot-remove with 'struct page'
objects for the region and further report the 'struct page' object memory as
free to the host.

3. 

If the system has more than B blocks amount of free memory, set a block as hot-remove target
If less than Y % free memory 

DARC for increasing free memory
Isolation for freezing compaction
Hot-remove for removing struct page

Opposite for memory pressure

Assuming 2 pages granularity isolation, 8 pages per block, 1 page on each block
for 'struct page'


AFAFAFAF AFAFAFAF AFAFAFAF AFAFAFAF

AFAFAFAF AFAFAFAF AFAFAFAF AFAFAAFF
AFAFAFAF AFAFAFAF AFAFAFAF AFAFAAII

AFAFAFAF AFAFAFAF AFAFAFAF AAAAFFII

A: Allocated, F: Freed, I: Isolated, R: Removed
