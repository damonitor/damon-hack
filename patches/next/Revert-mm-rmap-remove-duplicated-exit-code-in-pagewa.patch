From 162b194377c68130a631781526f3d1924c7a62bf Mon Sep 17 00:00:00 2001
From: SeongJae Park <sj@kernel.org>
Date: Mon, 29 Apr 2024 13:22:17 -0700
Subject: [PATCH] Revert "mm/rmap: remove duplicated exit code in pagewalk
 loop"

This reverts commit bbd3ea540ae1252b416d7daa0242c21f0442712d.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/rmap.c | 40 +++++++++++++++++++++++++---------------
 1 file changed, 25 insertions(+), 15 deletions(-)

diff --git a/mm/rmap.c b/mm/rmap.c
index 195d90d06bd6..e735b833fab1 100644
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@ -1675,7 +1675,9 @@ static bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,
 			/* Restore the mlock which got missed */
 			if (!folio_test_large(folio))
 				mlock_vma_folio(folio, vma);
-			goto walk_done_err;
+			page_vma_mapped_walk_done(&pvmw);
+			ret = false;
+			break;
 		}
 
 		pfn = pte_pfn(ptep_get(pvmw.pte));
@@ -1713,8 +1715,11 @@ static bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,
 			 */
 			if (!anon) {
 				VM_BUG_ON(!(flags & TTU_RMAP_LOCKED));
-				if (!hugetlb_vma_trylock_write(vma))
-					goto walk_done_err;
+				if (!hugetlb_vma_trylock_write(vma)) {
+					page_vma_mapped_walk_done(&pvmw);
+					ret = false;
+					break;
+				}
 				if (huge_pmd_unshare(mm, vma, address, pvmw.pte)) {
 					hugetlb_vma_unlock_write(vma);
 					flush_tlb_range(vma,
@@ -1729,7 +1734,8 @@ static bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,
 					 * actual page and drop map count
 					 * to zero.
 					 */
-					goto walk_done;
+					page_vma_mapped_walk_done(&pvmw);
+					break;
 				}
 				hugetlb_vma_unlock_write(vma);
 			}
@@ -1801,7 +1807,9 @@ static bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,
 			if (unlikely(folio_test_swapbacked(folio) !=
 					folio_test_swapcache(folio))) {
 				WARN_ON_ONCE(1);
-				goto walk_done_err;
+				ret = false;
+				page_vma_mapped_walk_done(&pvmw);
+				break;
 			}
 
 			/* MADV_FREE page check */
@@ -1840,17 +1848,23 @@ static bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,
 				 */
 				set_pte_at(mm, address, pvmw.pte, pteval);
 				folio_set_swapbacked(folio);
-				goto walk_done_err;
+				ret = false;
+				page_vma_mapped_walk_done(&pvmw);
+				break;
 			}
 
 			if (swap_duplicate(entry) < 0) {
 				set_pte_at(mm, address, pvmw.pte, pteval);
-				goto walk_done_err;
+				ret = false;
+				page_vma_mapped_walk_done(&pvmw);
+				break;
 			}
 			if (arch_unmap_one(mm, vma, address, pteval) < 0) {
 				swap_free(entry);
 				set_pte_at(mm, address, pvmw.pte, pteval);
-				goto walk_done_err;
+				ret = false;
+				page_vma_mapped_walk_done(&pvmw);
+				break;
 			}
 
 			/* See folio_try_share_anon_rmap(): clear PTE first. */
@@ -1858,7 +1872,9 @@ static bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,
 			    folio_try_share_anon_rmap_pte(folio, subpage)) {
 				swap_free(entry);
 				set_pte_at(mm, address, pvmw.pte, pteval);
-				goto walk_done_err;
+				ret = false;
+				page_vma_mapped_walk_done(&pvmw);
+				break;
 			}
 			if (list_empty(&mm->mmlist)) {
 				spin_lock(&mmlist_lock);
@@ -1898,12 +1914,6 @@ static bool try_to_unmap_one(struct folio *folio, struct vm_area_struct *vma,
 		if (vma->vm_flags & VM_LOCKED)
 			mlock_drain_local();
 		folio_put(folio);
-		continue;
-walk_done_err:
-		ret = false;
-walk_done:
-		page_vma_mapped_walk_done(&pvmw);
-		break;
 	}
 
 	mmu_notifier_invalidate_range_end(&range);
-- 
2.39.2

