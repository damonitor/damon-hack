From: SeongJae Park <sj@kernel.org>
Date: Fri, 22 Nov 2024 13:59:30 -0800
Subject: [PATCH] build fixups

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c | 30 +++++++++++++++++-------------
 1 file changed, 17 insertions(+), 13 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index ab4699e83c30..bda358333f84 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -533,7 +533,7 @@ struct damon_ctx *damon_new_ctx(void)
 	ctx->next_ops_update_sis = 0;
 
 	mutex_init(&ctx->kdamond_lock);
-	mutex_init(&ctx->call_ctonrol_lock);
+	mutex_init(&ctx->call_control_lock);
 #ifdef DAMON_WIP
 	mutex_init(&ctx->walk_control_lock);
 #endif
@@ -1189,14 +1189,14 @@ int damon_stop(struct damon_ctx **ctxs, int nr_ctxs)
 
 /**
  * damon_call() - Invoke a given function on a DAMON worker thread.
- * @ctx:	DAMON context to execute the request for.
- * @req:	Call request specification.
+ * @ctx:	DAMON context to execute the function for.
+ * @control:	Structure saving call request and result.
  *
  * Ask DAMON worker thread of @ctx to call a given function as specified in
- * @req and wait for the result.  The function can hence safely access the
+ * @control and wait for the result.  The function can hence safely access the
  * internal data of &struct damon_ctx including &struct damon_region objects
  * without additional locking.  The return code of the callback function will
- * be saved in &->return_code of @req.
+ * be saved in &->return_code of @control.
 
  * If DAMON is deactivated by watermarks or terminated before the function is
  * called back, the request is canceled.
@@ -1205,8 +1205,8 @@ int damon_stop(struct damon_ctx **ctxs, int nr_ctxs)
  */
 int damon_call(struct damon_ctx *ctx, struct damon_call_control *control)
 {
-	init_completion(&req->completion);
-	req->canceld = false;
+	init_completion(&control->completion);
+	control->canceled = false;
 
 	mutex_lock(&ctx->call_control_lock);
 	if (ctx->call_control) {
@@ -2124,17 +2124,17 @@ static void kdamond_callback(struct damon_ctx *ctx, bool cancel)
 	int ret = 0;
 
 	mutex_lock(&ctx->call_control_lock);
-	req = ctx->call_control;
+	control = ctx->call_control;
 	mutex_unlock(&ctx->call_control_lock);
-	if (!req)
+	if (!control)
 		return;
 	if (cancel) {
-		req->canceled = true;
+		control->canceled = true;
 	} else {
-		ret = req->fn(req->arg);
-		req->return_code = ret;
+		ret = control->fn(control->arg);
+		control->return_code = ret;
 	}
-	complete(&req->completion);
+	complete(&control->completion);
 	mutex_lock(&ctx->call_control_lock);
 	ctx->call_control = NULL;
 	mutex_unlock(&ctx->call_control_lock);
@@ -2165,7 +2165,9 @@ static int kdamond_wait_activation(struct damon_ctx *ctx)
 				ctx->callback.after_wmarks_check(ctx))
 			break;
 		kdamond_callback(ctx, true);
+#ifdef DAMON_WIP
 		damos_walk_cancel(ctx);
+#endif
 	}
 	return -EBUSY;
 }
@@ -2289,7 +2291,9 @@ static int kdamond_fn(void *data)
 	if (ctx->callback.before_terminate)
 		ctx->callback.before_terminate(ctx);
 	kdamond_callback(ctx, true);
+#ifdef DAMON_WIP
 	damos_walk_cancel(ctx);
+#endif
 	if (ctx->ops.cleanup)
 		ctx->ops.cleanup(ctx);
 	kfree(ctx->regions_score_histogram);
-- 
2.39.5

