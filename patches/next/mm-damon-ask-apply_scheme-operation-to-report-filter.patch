From: SeongJae Park <sj@kernel.org>
Date: Mon, 16 Dec 2024 12:25:50 -0800
Subject: [PATCH] mm/damon: ask apply_scheme() operation to report filtered-out
 bytes

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h |  5 ++--
 mm/damon/core.c       |  5 +++-
 mm/damon/paddr.c      | 57 +++++++++++++++++++++++++++----------------
 mm/damon/vaddr.c      |  2 +-
 4 files changed, 44 insertions(+), 25 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index 1418338994b6..3ca9c1b611f8 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -572,7 +572,8 @@ enum damon_ops_id {
  * @apply_scheme is called from @kdamond when a region for user provided
  * DAMON-based operation scheme is found.  It should apply the scheme's action
  * to the region and return bytes of the region that the action is successfully
- * applied.
+ * applied.  It should also report how many bytes of the region are excluded
+ * due to &struct damos_filter.
  * @target_valid should check whether the target is still valid for the
  * monitoring.
  * @cleanup is called from @kdamond just before its termination.
@@ -589,7 +590,7 @@ struct damon_operations {
 			struct damos *scheme);
 	unsigned long (*apply_scheme)(struct damon_ctx *context,
 			struct damon_target *t, struct damon_region *r,
-			struct damos *scheme);
+			struct damos *scheme, unsigned long *filtered_out);
 	bool (*target_valid)(struct damon_target *t);
 	void (*cleanup)(struct damon_ctx *context);
 };
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 19be99d45e95..23b6a482e3f6 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -1544,6 +1544,8 @@ static void damos_apply_scheme(struct damon_ctx *c, struct damon_target *t,
 	unsigned long sz = damon_sz_region(r);
 	struct timespec64 begin, end;
 	unsigned long sz_applied = 0;
+	/* bytes of the region that excluded by ops-handling damos filters */
+	unsigned long sz_ops_filtered = 0;
 	int err = 0;
 	/*
 	 * We plan to support multiple context per kdamond, as DAMON sysfs
@@ -1598,7 +1600,8 @@ static void damos_apply_scheme(struct damon_ctx *c, struct damon_target *t,
 		if (!err) {
 			trace_damos_before_apply(cidx, sidx, tidx, r,
 					damon_nr_regions(t), do_trace);
-			sz_applied = c->ops.apply_scheme(c, t, r, s);
+			sz_applied = c->ops.apply_scheme(c, t, r, s,
+					&sz_ops_filtered);
 		}
 		damos_walk_call_walk(c, t, r, s);
 		ktime_get_coarse_ts64(&end);
diff --git a/mm/damon/paddr.c b/mm/damon/paddr.c
index 0ca1bfd3d300..361fe9fc5ea3 100644
--- a/mm/damon/paddr.c
+++ b/mm/damon/paddr.c
@@ -248,7 +248,8 @@ static bool damos_pa_filter_out(struct damos *scheme, struct folio *folio)
 	return false;
 }
 
-static unsigned long damon_pa_pageout(struct damon_region *r, struct damos *s)
+static unsigned long damon_pa_pageout(struct damon_region *r, struct damos *s,
+		unsigned long *sz_filtered_out)
 {
 	unsigned long addr, applied;
 	LIST_HEAD(folio_list);
@@ -275,8 +276,10 @@ static unsigned long damon_pa_pageout(struct damon_region *r, struct damos *s)
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio))
+		if (damos_pa_filter_out(s, folio)) {
+			*sz_filtered_out += folio_size(folio);
 			goto put_folio;
+		}
 
 		folio_clear_referenced(folio);
 		folio_test_clear_young(folio);
@@ -297,7 +300,8 @@ static unsigned long damon_pa_pageout(struct damon_region *r, struct damos *s)
 }
 
 static inline unsigned long damon_pa_mark_accessed_or_deactivate(
-		struct damon_region *r, struct damos *s, bool mark_accessed)
+		struct damon_region *r, struct damos *s, bool mark_accessed,
+		unsigned long *sz_filtered_out)
 {
 	unsigned long addr, applied = 0;
 
@@ -307,8 +311,10 @@ static inline unsigned long damon_pa_mark_accessed_or_deactivate(
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio))
+		if (damos_pa_filter_out(s, folio)) {
+			*sz_filtered_out += folio_size(folio);
 			goto put_folio;
+		}
 
 		if (mark_accessed)
 			folio_mark_accessed(folio);
@@ -322,15 +328,17 @@ static inline unsigned long damon_pa_mark_accessed_or_deactivate(
 }
 
 static unsigned long damon_pa_mark_accessed(struct damon_region *r,
-	struct damos *s)
+	struct damos *s, unsigned long *sz_filtered_out)
 {
-	return damon_pa_mark_accessed_or_deactivate(r, s, true);
+	return damon_pa_mark_accessed_or_deactivate(r, s, true,
+			sz_filtered_out);
 }
 
 static unsigned long damon_pa_deactivate_pages(struct damon_region *r,
-	struct damos *s)
+	struct damos *s, unsigned long *sz_filtered_out)
 {
-	return damon_pa_mark_accessed_or_deactivate(r, s, false);
+	return damon_pa_mark_accessed_or_deactivate(r, s, false,
+			sz_filtered_out);
 }
 
 static unsigned int __damon_pa_migrate_folio_list(
@@ -454,7 +462,8 @@ static unsigned long damon_pa_migrate_pages(struct list_head *folio_list,
 	return nr_migrated;
 }
 
-static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s)
+static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s,
+		unsigned long *sz_filtered_out)
 {
 	unsigned long addr, applied;
 	LIST_HEAD(folio_list);
@@ -465,8 +474,10 @@ static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s)
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio))
+		if (damos_pa_filter_out(s, folio)) {
+			*sz_filtered_out += folio_size(folio);
 			goto put_folio;
+		}
 
 		if (!folio_isolate_lru(folio))
 			goto put_folio;
@@ -479,7 +490,8 @@ static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s)
 	return applied * PAGE_SIZE;
 }
 
-static unsigned long damon_pa_stat_full(struct damon_region *r, struct damos *s)
+static unsigned long damon_pa_stat_full(struct damon_region *r, struct damos *s,
+		unsigned long *sz_filtered_out)
 {
 	unsigned long addr, applied = 0;
 	LIST_HEAD(folio_list);
@@ -490,8 +502,10 @@ static unsigned long damon_pa_stat_full(struct damon_region *r, struct damos *s)
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio))
+		if (damos_pa_filter_out(s, folio)) {
+			*sz_filtered_out += folio_size(folio);
 			goto put_folio;
+		}
 		applied += folio_size(folio);
 put_folio:
 		folio_put(folio);
@@ -565,7 +579,8 @@ static int damon_pa_alloc(unsigned long pfn, struct damos *scheme)
 
 /* Preempt or yield memory regions from system */
 static unsigned long damon_pa_alloc_or_free(
-		struct damon_region *r, struct damos *s, bool alloc)
+		struct damon_region *r, struct damos *s, bool alloc,
+		unsigned long *sz_filtered_out)
 {
 	unsigned long pfn;
 	unsigned long applied = 0;
@@ -588,28 +603,28 @@ static unsigned long damon_pa_alloc_or_free(
 
 static unsigned long damon_pa_apply_scheme(struct damon_ctx *ctx,
 		struct damon_target *t, struct damon_region *r,
-		struct damos *scheme)
+		struct damos *scheme, unsigned long *filtered_out)
 {
 	switch (scheme->action) {
 	case DAMOS_PAGEOUT:
-		return damon_pa_pageout(r, scheme);
+		return damon_pa_pageout(r, scheme, filtered_out);
 	case DAMOS_LRU_PRIO:
-		return damon_pa_mark_accessed(r, scheme);
+		return damon_pa_mark_accessed(r, scheme, filtered_out);
 	case DAMOS_LRU_DEPRIO:
-		return damon_pa_deactivate_pages(r, scheme);
+		return damon_pa_deactivate_pages(r, scheme, filtered_out);
 	case DAMOS_MIGRATE_HOT:
 	case DAMOS_MIGRATE_COLD:
-		return damon_pa_migrate(r, scheme);
+		return damon_pa_migrate(r, scheme, filtered_out);
 #ifdef CONFIG_ACMA
 	case DAMOS_ALLOC:
-		return damon_pa_alloc_or_free(r, scheme, true);
+		return damon_pa_alloc_or_free(r, scheme, true, filtered_out);
 	case DAMOS_FREE:
-		return damon_pa_alloc_or_free(r, scheme, false);
+		return damon_pa_alloc_or_free(r, scheme, false, filtered_out);
 #endif
 	case DAMOS_STAT:
 		break;
 	case DAMOS_STAT_FULL:
-		return damon_pa_stat_full(r, scheme);
+		return damon_pa_stat_full(r, scheme, filtered_out);
 	default:
 		/* DAMOS actions that not yet supported by 'paddr'. */
 		break;
diff --git a/mm/damon/vaddr.c b/mm/damon/vaddr.c
index b9eaa20b73b9..4c371efc0eb0 100644
--- a/mm/damon/vaddr.c
+++ b/mm/damon/vaddr.c
@@ -655,7 +655,7 @@ static unsigned long damos_madvise(struct damon_target *target,
 
 static unsigned long damon_va_apply_scheme(struct damon_ctx *ctx,
 		struct damon_target *t, struct damon_region *r,
-		struct damos *scheme)
+		struct damos *scheme, unsigned long *filtered_out)
 {
 	int madv_action;
 
-- 
2.39.5

