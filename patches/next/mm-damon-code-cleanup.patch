From: SeongJae Park <sj@kernel.org>
Date: Sat, 26 Jul 2025 13:29:49 -0700
Subject: [PATCH] mm/damon: code cleanup

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c  | 9 +++++----
 mm/damon/paddr.c | 2 +-
 2 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index 668353554939..4f684ec7a200 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -1480,7 +1480,7 @@ int damos_walk(struct damon_ctx *ctx, struct damos_walk_control *control)
  * NOTE: we may be able to implement this as a lockless queue, and allow any
  * context.  As the overhead is unknown, and region-based DAMON logics would
  * guarantee the reports would be not made that frequently, let's start with
- * this simple implementation, though.
+ * this simple implementation.
  */
 void damon_report_access(struct damon_access_report *report)
 {
@@ -2585,7 +2585,7 @@ static void kdamond_apply_access_report(struct damon_access_report *report,
 	}
 }
 
-static unsigned int kdamond_account_absence_of_access(struct damon_ctx *ctx)
+static unsigned int kdamond_apply_zero_access_report(struct damon_ctx *ctx)
 {
 	struct damon_target *t;
 	struct damon_region *r;
@@ -2621,10 +2621,11 @@ static unsigned int kdamond_check_reported_accesses(struct damon_ctx *ctx)
 		if (report->pid && !damon_target_has_pid(ctx))
 			continue;
 		damon_for_each_target(t, ctx)
-			kdamond_apply_access_report( report, t, ctx);
+			kdamond_apply_access_report(report, t, ctx);
 	}
 	mutex_unlock(&damon_access_reports_lock);
-	return kdamond_account_absence_of_access(ctx);
+	/* For nr_accesses_bp, absence of access should also be reported. */
+	return kdamond_apply_zero_access_report(ctx);
 }
 
 /*
diff --git a/mm/damon/paddr.c b/mm/damon/paddr.c
index c47f91212ae7..68c309ad1aa4 100644
--- a/mm/damon/paddr.c
+++ b/mm/damon/paddr.c
@@ -98,10 +98,10 @@ static unsigned int damon_pa_check_accesses(struct damon_ctx *ctx)
 	return max_nr_accesses;
 }
 
-/* todo: batch or remove tlb flushing */
 static bool damon_pa_fault_change_protection_one(struct folio *folio,
 		struct vm_area_struct *vma, unsigned long addr, void *arg)
 {
+	/* todo: batch or remove tlb flushing */
 	struct mmu_gather tlb;
 
 	if (!vma_is_accessible(vma))
-- 
2.39.5

