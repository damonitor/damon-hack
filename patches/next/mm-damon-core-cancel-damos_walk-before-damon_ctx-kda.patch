From: SeongJae Park <sj@kernel.org>
Date: Thu, 1 Jan 2026 14:00:16 -0800
Subject: [PATCH] mm/damon/core: cancel damos_walk() before damon_ctx->kdamond
 reset

damos_walk() request is canceled after damon_ctx->kdamond is reset.
This can make weird situations where damon_is_running() returns false
but the DAMON context has the damos_walk() request linked.  There was
similar situation for damon_call() requests handling, which was able to
cause use-after-free bug.  Because damos_walk() is always synchronously
handled, there is no such problematic race case.  But, keeping it as is
could stem another complicated race condition bugs in future.  Avoid the
racy situation by cancelling the requests before the ->kdamond reset.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index 8b81726d77d9..e6f44827c627 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -2856,14 +2856,13 @@ static int kdamond_fn(void *data)
 
 	kfree(ctx->regions_score_histogram);
 	kdamond_call(ctx, true);
+	damos_walk_cancel(ctx);
 
 	pr_debug("kdamond (%d) finishes\n", current->pid);
 	mutex_lock(&ctx->kdamond_lock);
 	ctx->kdamond = NULL;
 	mutex_unlock(&ctx->kdamond_lock);
 
-	damos_walk_cancel(ctx);
-
 	mutex_lock(&damon_lock);
 	nr_running_ctxs--;
 	if (!nr_running_ctxs && running_exclusive_ctxs)
-- 
2.47.3

