From: SeongJae Park <sj@kernel.org>
Date: Mon, 29 Dec 2025 21:35:01 -0800
Subject: [PATCH] mm/damon/core: cleanup targets right after kdamond_fn() main
 loop

In the past, DAMON sysfs was putting target pids before the given DAMON
context terminates, using the damon_callback->before_terminate callback.
For the reason, only damon_region objects were cleaned up right after
kdamond_fn()'s main loop.  Commit ff01aba6e458 ("mm/damon/vaddr: put pid
in cleanup_target()") made it is no more necessary, by embedding the pid
cleanup inside damon_target deallocation.  Further, commit 3a69f1635769
("mm/damon/core: destroy targets when kdamond_fn() finish") made the
targets deallocated just before kdamond_fn() returns.

Cleanup both region and targets at once, right after the main loop.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index b248d46e400b..499bb988fc73 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -3151,8 +3151,6 @@ static unsigned int kdamond_check_reported_accesses(struct damon_ctx *ctx)
 static int kdamond_fn(void *data)
 {
 	struct damon_ctx *ctx = data;
-	struct damon_target *t;
-	struct damon_region *r, *next;
 	unsigned int max_nr_accesses = 0;
 	unsigned long sz_limit = 0;
 
@@ -3260,10 +3258,7 @@ static int kdamond_fn(void *data)
 		}
 	}
 done:
-	damon_for_each_target(t, ctx) {
-		damon_for_each_region_safe(r, next, t)
-			damon_destroy_region(r, t);
-	}
+	damon_destroy_targets(ctx);
 
 	if (ctx->ops.cleanup)
 		ctx->ops.cleanup(ctx);
@@ -3283,7 +3278,6 @@ static int kdamond_fn(void *data)
 		running_exclusive_ctxs = false;
 	mutex_unlock(&damon_lock);
 
-	damon_destroy_targets(ctx);
 	return 0;
 }
 
-- 
2.47.3

