From: SeongJae Park <sj@kernel.org>
Date: Fri, 22 Nov 2024 14:01:43 -0800
Subject: [PATCH] mm/damon/core: drop WIP mark from damos_walk

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c | 18 +-----------------
 1 file changed, 1 insertion(+), 17 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index bda358333f84..142f57d773d8 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -534,9 +534,7 @@ struct damon_ctx *damon_new_ctx(void)
 
 	mutex_init(&ctx->kdamond_lock);
 	mutex_init(&ctx->call_control_lock);
-#ifdef DAMON_WIP
 	mutex_init(&ctx->walk_control_lock);
-#endif
 
 	ctx->attrs.min_nr_regions = 10;
 	ctx->attrs.max_nr_regions = 1000;
@@ -1222,7 +1220,6 @@ int damon_call(struct damon_ctx *ctx, struct damon_call_control *control)
 	return 0;
 }
 
-#ifdef DAMON_WIP
 /**
  * damos_walk() - Invoke given functions for regions that DAMOS will be applied.
  * @ctx:	DAMON context to execute the request for.
@@ -1249,7 +1246,6 @@ int damos_walk(struct damon_ctx *ctx, struct damos_walk_control *control)
 		return -ECANCELED;
 	return 0;
 }
-#endif
 
 /*
  * Reset the aggregated monitoring results ('nr_accesses' of each region).
@@ -1430,7 +1426,6 @@ static bool damos_filter_out(struct damon_ctx *ctx, struct damon_target *t,
 	return false;
 }
 
-#ifdef DAMON_WIP
 static void damos_walk_call_prep(struct damon_ctx *ctx)
 {
 	struct damos_walk_control *control;
@@ -1495,7 +1490,6 @@ static void damos_walk_cancel(struct damon_ctx *ctx)
 	ctx->walk_control = NULL;
 	mutex_unlock(&ctx->walk_control_lock);
 }
-#endif
 
 static void damos_apply_scheme(struct damon_ctx *c, struct damon_target *t,
 		struct damon_region *r, struct damos *s)
@@ -1553,6 +1547,7 @@ static void damos_apply_scheme(struct damon_ctx *c, struct damon_target *t,
 		if (damos_filter_out(c, t, r, s))
 			return;
 		ktime_get_coarse_ts64(&begin);
+		damos_walk_call_walk(c, t, r, s);
 		if (c->callback.before_damos_apply)
 			err = c->callback.before_damos_apply(c, t, r, s);
 		if (!err) {
@@ -1560,9 +1555,6 @@ static void damos_apply_scheme(struct damon_ctx *c, struct damon_target *t,
 					damon_nr_regions(t), do_trace);
 			sz_applied = c->ops.apply_scheme(c, t, r, s);
 		}
-#ifdef DAMON_WIP
-		damos_walk_call_walk(c, t, r, s);
-#endif
 		ktime_get_coarse_ts64(&end);
 		quota->total_charged_ns += timespec64_to_ns(&end) -
 			timespec64_to_ns(&begin);
@@ -1822,9 +1814,7 @@ static void kdamond_apply_schemes(struct damon_ctx *c)
 			continue;
 
 		has_schemes_to_apply = true;
-#ifdef DAMON_WIP
 		damos_walk_call_prep(c);
-#endif
 
 		damos_adjust_quota(c, s);
 	}
@@ -1840,9 +1830,7 @@ static void kdamond_apply_schemes(struct damon_ctx *c)
 	damon_for_each_scheme(s, c) {
 		if (c->passed_sample_intervals < s->next_apply_sis)
 			continue;
-#ifdef DAMON_WIP
 		damos_walk_call_complete(c, s);
-#endif
 		s->next_apply_sis = c->passed_sample_intervals +
 			(s->apply_interval_us ? s->apply_interval_us :
 			 c->attrs.aggr_interval) / sample_interval;
@@ -2165,9 +2153,7 @@ static int kdamond_wait_activation(struct damon_ctx *ctx)
 				ctx->callback.after_wmarks_check(ctx))
 			break;
 		kdamond_callback(ctx, true);
-#ifdef DAMON_WIP
 		damos_walk_cancel(ctx);
-#endif
 	}
 	return -EBUSY;
 }
@@ -2291,9 +2277,7 @@ static int kdamond_fn(void *data)
 	if (ctx->callback.before_terminate)
 		ctx->callback.before_terminate(ctx);
 	kdamond_callback(ctx, true);
-#ifdef DAMON_WIP
 	damos_walk_cancel(ctx);
-#endif
 	if (ctx->ops.cleanup)
 		ctx->ops.cleanup(ctx);
 	kfree(ctx->regions_score_histogram);
-- 
2.39.5

