From: SeongJae Park <sj@kernel.org>
Date: Fri, 22 Nov 2024 14:14:15 -0800
Subject: [PATCH] mm/damon/core: ensure DAMON is running for damon_call() and
 damos_walk()

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index 142f57d773d8..be19cd6d68c5 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -1185,6 +1185,16 @@ int damon_stop(struct damon_ctx **ctxs, int nr_ctxs)
 	return err;
 }
 
+static bool damon_is_running(struct damon_ctx *ctx)
+{
+	bool running;
+
+	mutex_lock(&ctx->kdamond_lock);
+	running = ctx->kdamond != NULL;
+	mutex_unlock(&ctx->kdmond_lock);
+	return running;
+}
+
 /**
  * damon_call() - Invoke a given function on a DAMON worker thread.
  * @ctx:	DAMON context to execute the function for.
@@ -1213,7 +1223,8 @@ int damon_call(struct damon_ctx *ctx, struct damon_call_control *control)
 	}
 	ctx->call_control = control;
 	mutex_unlock(&ctx->call_control_lock);
-
+	if (!damon_is_running(ctx))
+		return -EINVAL;
 	wait_for_completion(&control->completion);
 	if (control->canceled)
 		return -ECANCELED;
@@ -1240,7 +1251,8 @@ int damos_walk(struct damon_ctx *ctx, struct damos_walk_control *control)
 	}
 	ctx->walk_control = control;
 	mutex_unlock(&ctx->walk_control_lock);
-
+	if (!damon_is_running(ctx))
+		return -EINVAL;
 	wait_for_completion(&control->completion);
 	if (control->canceled)
 		return -ECANCELED;
-- 
2.39.5

