From b496298ba6eee48341dc4bf40fd2ad362c8f53fa Mon Sep 17 00:00:00 2001
From: SeongJae Park <sj@kernel.org>
Date: Wed, 19 Jun 2024 14:35:45 -0700
Subject: [PATCH] mm/damon/core: force max_nr_regions always

DAMON keeps the number of regions under max_nr_regions by skipping
regions split operations when doing so can make the number higher than
the limit.  It works well for preventing violation of the limit, but not
that well once the violation is happened.  The limit violation can
happen in some cases, though.  For an example, the user could reduce
max_nr_regions while DAMON is running, to be lower than the current
number of regions.

The number is assumed to be gradually decreased until it becomes lower
than the new limit by continued merge operation.  However, if the real
number of regions of different access pattern in the monitoring target
is higher than the new limit, it would take indefinite time to meet the
limit.  As a result, the system could suffer from high monitoring
overhead of DAMON.

Fix the problem by checking the number of regions and repeating the
merge operations in kdamond_merge_regions().  Also, increase the
aggressiveness of the merge operation for every repeat to ensure the
progress.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c | 20 ++++++++++++++++++--
 1 file changed, 18 insertions(+), 2 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index e638dc336fb9..33da4f947d99 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -1749,14 +1749,30 @@ static void damon_merge_regions_of(struct damon_target *t, unsigned int thres,
  * access frequencies are similar.  This is for minimizing the monitoring
  * overhead under the dynamically changeable access pattern.  If a merge was
  * unnecessarily made, later 'kdamond_split_regions()' will revert it.
+ *
+ * The total number of regions could be temporarily higher than the
+ * user-defined limit, max_nr_regions for some cases.  For an example, the user
+ * updates max_nr_regions to a number that lower than the current number of
+ * regions while DAMON is running.  Depending on the access pattern, it could
+ * take indefinitve time to reduce the number below the limit.  For such a
+ * case, repeat merging until the limit is met while increasing @threshold and
+ * @sz_limit.
  */
 static void kdamond_merge_regions(struct damon_ctx *c, unsigned int threshold,
 				  unsigned long sz_limit)
 {
 	struct damon_target *t;
+	unsigned int nr_regions;
 
-	damon_for_each_target(t, c)
-		damon_merge_regions_of(t, threshold, sz_limit);
+	do {
+		nr_regions = 0;
+		damon_for_each_target(t, c) {
+			damon_merge_regions_of(t, threshold, sz_limit);
+			nr_regions += damon_nr_regions(t);
+		}
+		threshold = max(1, threshold * 2);
+		sz_limit = max(1, sz_limit * 2);
+	} while (nr_regions > c->attrs.max_nr_regions);
 }
 
 /*
-- 
2.39.2

