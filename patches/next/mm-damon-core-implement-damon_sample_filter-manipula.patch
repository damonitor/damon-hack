From: SeongJae Park <sj@kernel.org>
Date: Tue, 2 Dec 2025 22:32:56 -0800
Subject: [PATCH] mm/damon/core: implement damon_sample_filter manipulations

Add basic manipulation helper functions for damon_sample_filter data
structure.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h | 15 +++++++++++++++
 mm/damon/core.c       | 45 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 60 insertions(+)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index 8ee92a96a9d96..a85ac35db83d6 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -958,6 +958,12 @@ static inline unsigned long damon_sz_region(struct damon_region *r)
 #define damon_for_each_target_safe(t, next, ctx)	\
 	list_for_each_entry_safe(t, next, &(ctx)->adaptive_targets, list)
 
+#define damon_for_each_sample_filter(f, control) \
+	list_for_each_entry(f, &(control)->sample_filters, list)
+
+#define damon_for_each_sample_filter_safe(f, next, control) \
+	list_for_each_entry_safe(f, next, &(control)->sample_filters, list)
+
 #define damon_for_each_scheme(s, ctx) \
 	list_for_each_entry(s, &(ctx)->schemes, list)
 
@@ -1033,6 +1039,15 @@ void damon_free_target(struct damon_target *t);
 void damon_destroy_target(struct damon_target *t, struct damon_ctx *ctx);
 unsigned int damon_nr_regions(struct damon_target *t);
 
+struct damon_sample_filter *damon_new_sample_filter(
+		enum damon_sample_filter_type filter_type, bool matching,
+		bool allow);
+void damon_add_sample_filter(struct damon_sample_control *ctrl,
+		struct damon_sample_filter *filter);
+void damon_free_sample_filter(struct damon_sample_filter *filter);
+void damon_destroy_sample_filter(struct damon_sample_filter *filter,
+		struct damon_sample_control *ctrl);
+
 struct damon_ctx *damon_new_ctx(void);
 void damon_destroy_ctx(struct damon_ctx *ctx);
 int damon_set_attrs(struct damon_ctx *ctx, struct damon_attrs *attrs);
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 8fd7b88d4bb46..00510c1dfe48b 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -534,6 +534,46 @@ unsigned int damon_nr_regions(struct damon_target *t)
 	return t->nr_regions;
 }
 
+struct damon_sample_filter *damon_new_sample_filter(
+		enum damon_sample_filter_type filter_type, bool matching,
+		bool allow)
+{
+	struct damon_sample_filter *filter;
+
+	filter = kmalloc(sizeof(*filter), GFP_KERNEL);
+	if (!filter)
+		return NULL;
+	filter->type = filter_type;
+	filter->matching = matching;
+	filter->allow = allow;
+	INIT_LIST_HEAD(&filter->list);
+	return filter;
+}
+
+void damon_add_sample_filter(struct damon_sample_control *ctrl,
+		struct damon_sample_filter *filter)
+{
+	list_add_tail(&filter->list, &ctrl->sample_filters);
+}
+
+static void damon_del_sample_filter(struct damon_sample_filter *f,
+		struct damon_sample_control *ctrl)
+{
+	list_del(&f->list);
+}
+
+void damon_free_sample_filter(struct damon_sample_filter *f)
+{
+	kfree(f);
+}
+
+void damon_destroy_sample_filter(struct damon_sample_filter *f,
+		struct damon_sample_control *ctrl)
+{
+	damon_del_sample_filter(f, ctrl);
+	damon_free_sample_filter(f);
+}
+
 struct damon_ctx *damon_new_ctx(void)
 {
 	struct damon_ctx *ctx;
@@ -562,6 +602,7 @@ struct damon_ctx *damon_new_ctx(void)
 	ctx->attrs.max_nr_regions = 1000;
 
 	ctx->sample_control.primitives_enabled.page_table = true;
+	INIT_LIST_HEAD(&ctx->sample_control.sample_filters);
 
 	ctx->addr_unit = 1;
 	ctx->min_region_sz = DAMON_MIN_REGION_SZ;
@@ -583,12 +624,16 @@ static void damon_destroy_targets(struct damon_ctx *ctx)
 void damon_destroy_ctx(struct damon_ctx *ctx)
 {
 	struct damos *s, *next_s;
+	struct damon_sample_filter *f, *next_f;
 
 	damon_destroy_targets(ctx);
 
 	damon_for_each_scheme_safe(s, next_s, ctx)
 		damon_destroy_scheme(s);
 
+	damon_for_each_sample_filter_safe(f, next_f, &ctx->sample_control)
+		damon_destroy_sample_filter(f, &ctx->sample_control);
+
 	kfree(ctx);
 }
 
-- 
2.47.3

