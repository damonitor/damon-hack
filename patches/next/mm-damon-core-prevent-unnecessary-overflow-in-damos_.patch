From: Quanmin Yan <yanquanmin1@huawei.com>
Date: Thu, 21 Aug 2025 20:55:55 +0800
Subject: [PATCH] mm/damon/core: prevent unnecessary overflow in
 damos_set_effective_quota()

On 32-bit systems, the throughput calculation in function
damos_set_effective_quota() is prone to unnecessary multiplication
overflow. Using mult_frac() to fix it.

Andrew Paniakin also recently found and privately reported this
issue, on 64 bit systems. This can also happen on 64-bit systems,
once the charged size exceeds ~17 TiB. On systems running for long
time in production, this issue can actually happen.

More specifically, when a DAMOS scheme having the time quota run
for longtime, throughput calculation can overflow and set esz too
small. As a result, speed of the scheme get unexpectedly slow.

Fixes: 1cd243030059 ("mm/damon/schemes: implement time quota")
Cc: <stable@vger.kernel.org> # 5.16.x
Signed-off-by: Quanmin Yan <yanquanmin1@huawei.com>
Reported-by: Andrew Paniakin <apanyaki@amazon.com>
Closes: N/A # privately reported
Link: https://patch.msgid.link/20250821125555.3020951-1-yanquanmin1@huawei.com
Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/core.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/mm/damon/core.c b/mm/damon/core.c
index 93bad6d0da5b..5ac1433860a3 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -2092,8 +2092,8 @@ static void damos_set_effective_quota(struct damos_quota *quota)
 
 	if (quota->ms) {
 		if (quota->total_charged_ns)
-			throughput = quota->total_charged_sz * 1000000 /
-				quota->total_charged_ns;
+			throughput = mult_frac(quota->total_charged_sz, 1000000,
+							quota->total_charged_ns);
 		else
 			throughput = PAGE_SIZE * 1024;
 		esz = min(throughput * quota->ms, esz);
-- 
2.39.5

