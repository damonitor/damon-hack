From: SeongJae Park <sj@kernel.org>
Date: Tue, 28 Jan 2025 17:56:10 -0800
Subject: [PATCH] mm/damon: intervals tuning parameters refactoring

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h |  56 ++++----
 mm/damon/core.c       |  73 ++++++----
 mm/damon/sysfs.c      | 311 ++++++++++++++++++++++++++++--------------
 3 files changed, 285 insertions(+), 155 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index eed52dc0875d..c3e9431c3e4c 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -669,20 +669,47 @@ struct damon_call_control {
 	bool canceled;
 };
 
+/**
+ * struct damon_intervals_goal - Monitoring intervals auto-tuning goal.
+ *
+ * @samples:		Number of positive access check samples to achieve.
+ * @aggrs:		Number of aggregations to acheive @samples within.
+ * @min_sample_us:	Minimum resulting sampling interval in microseconds.
+ * @max_sample_us:	Maximum resulting sampling interval in microseconds.
+ * @aggr_samples:	Aggregation to sample interval ratio.
+ *
+ * DAMON automatically tunes &damon_attrs->sample_interval and
+ * &damon_attrs->aggr_interval aiming the number of access check samples that
+ * shown positive result (was accessed) within @aggrs aggregations be same to
+ * @samples.  The logic increases &damon_attrs->aggr_interval and
+ * &damon_attrs->sampling_interval in same ratio (@aggr_samples) if the current
+ * positive access samples ratio is lower than the target for each @aggrs
+ * aggregations, and vice versa.
+ *
+ * If @aggrs is zero, the tuning is disabled.  If any input makes no sense
+ * (e.g., @min_sample_us is samller than @max_sample_us, or
+ * &damon_attrs->sample_interval is out of @min_sample_us-@max_sample_us
+ * range), damon_commit_ctx() returns an error.
+ */
+struct damon_intervals_goal {
+	unsigned long samples;
+	unsigned long aggrs;
+	unsigned long min_sample_us;
+	unsigned long max_sample_us;
+	unsigned long aggr_samples;
+};
+
 /**
  * struct damon_attrs - Monitoring attributes for accuracy/overhead control.
  *
  * @sample_interval:		The time between access samplings.
  * @aggr_interval:		The time between monitor results aggregations.
  * @ops_update_interval:	The time between monitoring operations updates.
+ * @intervals_goal:		Intervals auto-tuning goal.
  * @min_nr_regions:		The minimum number of adaptive monitoring
  *				regions.
  * @max_nr_regions:		The maximum number of adaptive monitoring
  *				regions.
- * @tune_interval_aggrs:	Intervals tuning time interval in number of
- *				aggregations.
- * @target_access_samples_bp:	Intervals tuning target access samples ratio.
- * @max_aggr_interval:		Maximum aggregation interval after tuning.
  *
  * For each @sample_interval, DAMON checks whether each region is accessed or
  * not during the last @sample_interval.  If such access is found, DAMON
@@ -693,33 +720,14 @@ struct damon_call_control {
  * and applies the changes for each @ops_update_interval.  All time intervals
  * are in micro-seconds.  Please refer to &struct damon_operations and &struct
  * damon_callback for more detail.
- *
- * If @tune_interval_aggrs is not zero, DAMON automatically tunes
- * @aggr_interval and @sample_interval aiming the positive access check samples
- * to total samples ratio within @tune_interval_aggrs of aggregations be same
- * to @target_access_samples_bp.  The logic increases @aggr_interval and
- * @sampling_interval in same ratio if the current positive access samples
- * ratio is lower than the target, and vice versa.  The user-set
- * @sampling_interval and @aggr_interval work as minimum values of the
- * after-tune parameters.  User can set the maximum value of tuned aggregation
- * interval via @max_aggr_interval.  Because the tuning logic keeps the
- * @sample_interval to @aggr_interval ratio, @max_aggr_interval can be used to
- * limit @sample_interval, too.
  */
 struct damon_attrs {
 	unsigned long sample_interval;
 	unsigned long aggr_interval;
 	unsigned long ops_update_interval;
+	struct damon_intervals_goal intervals_goal;
 	unsigned long min_nr_regions;
 	unsigned long max_nr_regions;
-
-	unsigned long tune_interval_aggrs;
-	unsigned int target_access_samples_bp;
-	unsigned long max_aggr_interval;
-
-/* private: internal use only */
-	unsigned long access_samples;
-	unsigned long min_aggr_interval;
 };
 
 /**
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 9a2c3e4209cb..bd341aa464a5 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -644,6 +644,27 @@ static void damon_update_monitoring_results(struct damon_ctx *ctx,
 					r, old_attrs, new_attrs);
 }
 
+/*
+ * damon_valid_intervals_goal() - return if the intervals goal of @attrs is
+ * valid.
+ */
+static bool damon_valid_intervals_goal(struct damon_attrs *attrs)
+{
+	struct damon_intervals_goal *goal = &attrs->intervals_goal;
+
+	/* tuning is disabled */
+	if (!goal->aggrs)
+		return true;
+	if (goal->min_sample_us > goal->max_sample_us)
+		return false;
+	if (attrs->sample_interval < goal->min_sample_us ||
+			goal->max_sample_us < attrs->sample_interval)
+		return false;
+	if (!goal->aggr_samples)
+		return false;
+	return true;
+}
+
 /**
  * damon_set_attrs() - Set attributes for the monitoring.
  * @ctx:		monitoring context
@@ -664,6 +685,9 @@ int damon_set_attrs(struct damon_ctx *ctx, struct damon_attrs *attrs)
 		attrs->sample_interval : 1;
 	struct damos *s;
 
+	if (!damon_valid_intervals_goal(attrs))
+		return -EINVAL;
+
 	if (attrs->min_nr_regions < 3)
 		return -EINVAL;
 	if (attrs->min_nr_regions > attrs->max_nr_regions)
@@ -1312,9 +1336,7 @@ static unsigned long damon_get_intervals_adaptation_bp(struct damon_ctx *c)
 {
 	struct damon_target *t;
 	struct damon_region *r;
-	unsigned long nr_regions = 0;
-	unsigned long access_samples = 0;
-	unsigned long max_access_samples, access_samples_bp, score_bp;
+	unsigned long nr_regions = 0, access_samples = 0, score_bp;
 	unsigned long adaptation_bp;
 
 	damon_for_each_target(t, c) {
@@ -1322,15 +1344,12 @@ static unsigned long damon_get_intervals_adaptation_bp(struct damon_ctx *c)
 		damon_for_each_region(r, t)
 			access_samples += r->nr_accesses;
 	}
-	max_access_samples = damon_max_nr_accesses(&c->attrs) * nr_regions;
-	access_samples_bp = access_samples * 10000 / max_access_samples;
-	score_bp = access_samples_bp * 10000 /
-		c->attrs.target_access_samples_bp;
+	score_bp = access_samples * 10000 / c->attrs.intervals_goal.samples;
 	adaptation_bp = damon_feed_loop_next_input(100000000, score_bp) /
 		10000;
 
-	pr_info("access_ratio bp %lu, score_bp %lu, adaptation bp %lu\n",
-			access_samples_bp, score_bp, adaptation_bp);
+	pr_info("access_samples %lu/%lu, score_bp %lu, adaptation bp %lu\n",
+			access_samples, score_bp, adaptation_bp);
 	return adaptation_bp;
 }
 
@@ -1338,25 +1357,22 @@ static void kdamond_tune_intervals(struct damon_ctx *c)
 {
 	unsigned long adaptation_bp, sample_to_aggr_bp;
 	struct damon_attrs new_attrs;
-
-	if (!c->attrs.tune_interval_aggrs)
-		return;
+	struct damon_intervals_goal *goal;
 
 	adaptation_bp = damon_get_intervals_adaptation_bp(c);
 	if (adaptation_bp == 10000)
 		return;
 
 	new_attrs = c->attrs;
-	new_attrs.aggr_interval = min(
-			c->attrs.aggr_interval * adaptation_bp / 10000,
-			c->attrs.max_aggr_interval);
-	new_attrs.aggr_interval = max(new_attrs.aggr_interval,
-			c->attrs.min_aggr_interval);
-	/* todo: keep the initial ratio */
-	sample_to_aggr_bp = c->attrs.sample_interval * 10000 /
-		c->attrs.aggr_interval;
-	new_attrs.sample_interval = new_attrs.aggr_interval * sample_to_aggr_bp
-		/ 10000;
+	goal = &c->attrs.intervals_goal;
+	new_attrs.sample_interval = min(
+			c->attrs.sample_interval * adaptation_bp / 10000,
+			goal->max_sample_us);
+	new_attrs.sample_interval = max(new_attrs.sample_interval,
+			goal->min_sample_us);
+	new_attrs.aggr_interval = new_attrs.sample_interval *
+		goal->aggr_samples;
+
 	pr_info("tune intervals to %lu %lu\n\n",
 			new_attrs.sample_interval, new_attrs.aggr_interval);
 	damon_set_attrs(c, &new_attrs);
@@ -2299,7 +2315,7 @@ static void kdamond_init_intervals_sis(struct damon_ctx *ctx)
 	ctx->next_ops_update_sis = ctx->attrs.ops_update_interval /
 		sample_interval;
 	ctx->next_intervals_tune_sis = ctx->next_aggregation_sis *
-		ctx->attrs.tune_interval_aggrs;
+		ctx->attrs.intervals_goal.aggrs;
 
 	/* todo: ensure apply_interval_us > sample_interval */
 	damon_for_each_scheme(scheme, ctx) {
@@ -2325,9 +2341,6 @@ static int kdamond_fn(void *data)
 	complete(&ctx->kdamond_started);
 	kdamond_init_intervals_sis(ctx);
 
-	if (ctx->attrs.tune_interval_aggrs)
-		ctx->attrs.min_aggr_interval = ctx->attrs.aggr_interval;
-
 	if (ctx->ops.init)
 		ctx->ops.init(ctx);
 	ctx->regions_score_histogram = kmalloc_array(DAMOS_MAX_SCORE + 1,
@@ -2388,12 +2401,12 @@ static int kdamond_fn(void *data)
 		if (ctx->passed_sample_intervals >= next_aggregation_sis) {
 			ctx->next_aggregation_sis = next_aggregation_sis +
 				ctx->attrs.aggr_interval / sample_interval;
-			if (ctx->passed_sample_intervals >=
+			if (ctx->attrs.intervals_goal.aggrs &&
+					ctx->passed_sample_intervals >=
 					ctx->next_intervals_tune_sis) {
 				ctx->next_intervals_tune_sis +=
-					ctx->attrs.aggr_interval /
-					sample_interval *
-					ctx->attrs.tune_interval_aggrs;
+					ctx->attrs.intervals_goal.aggr_samples * 
+					ctx->attrs.intervals_goal.aggrs;
 				kdamond_tune_intervals(ctx);
 			}
 
diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index 8bc5e3e40893..98ddc50797cd 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -409,150 +409,259 @@ static const struct kobj_type damon_sysfs_targets_ktype = {
 };
 
 /*
- * intervals directory
+ * intervals goal directory
  */
 
-struct damon_sysfs_intervals {
+struct damon_sysfs_intervals_goal {
 	struct kobject kobj;
-	unsigned long sample_us;
-	unsigned long aggr_us;
-	unsigned long update_us;
-
-	unsigned long tune_aggrs;
-	unsigned long target_access_samples_bp;
-	unsigned long max_aggr_us;
-	unsigned long tuned_aggr_us;
+	unsigned long samples;
+	unsigned long aggrs;
+	unsigned long min_sample_us;
+	unsigned long max_sample_us;
+	unsigned long aggr_samples;
 };
 
-static struct damon_sysfs_intervals *damon_sysfs_intervals_alloc(
-		unsigned long sample_us, unsigned long aggr_us,
-		unsigned long update_us)
+static struct damon_sysfs_intervals_goal *damon_sysfs_intervals_goal_alloc(
+		unsigned long samples, unsigned long aggrs,
+		unsigned long min_sample_us, unsigned long max_sample_us,
+		unsigned long aggr_samples)
 {
-	struct damon_sysfs_intervals *intervals = kmalloc(sizeof(*intervals),
+	struct damon_sysfs_intervals_goal *goal = kmalloc(sizeof(*goal),
 			GFP_KERNEL);
 
-	if (!intervals)
+	if (!goal)
 		return NULL;
 
-	intervals->kobj = (struct kobject){};
-	intervals->sample_us = sample_us;
-	intervals->aggr_us = aggr_us;
-	intervals->update_us = update_us;
+	goal->kobj = (struct kobject){};
+	goal->samples = samples;
+	goal->aggrs = aggrs;
+	goal->min_sample_us = min_sample_us;
+	goal->max_sample_us = max_sample_us;
+	goal->aggr_samples = aggr_samples;
+	return goal;
+}
 
-	intervals->tune_aggrs = 0;
-	intervals->target_access_samples_bp = 0;
-	intervals->max_aggr_us = 0;
-	intervals->tuned_aggr_us = 0;
+static ssize_t samples_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
 
-	return intervals;
+	return sysfs_emit(buf, "%lu\n", goal->samples);
 }
 
-static ssize_t sample_us_show(struct kobject *kobj,
+static ssize_t samples_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
+	unsigned long nr;
+	int err = kstrtoul(buf, 0, &nr);
+
+	if (err)
+		return err;
+
+	goal->samples = nr;
+	return count;
+}
+
+static ssize_t aggrs_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
 
-	return sysfs_emit(buf, "%lu\n", intervals->sample_us);
+	return sysfs_emit(buf, "%lu\n", goal->aggrs);
 }
 
-static ssize_t sample_us_store(struct kobject *kobj,
+static ssize_t aggrs_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
-	unsigned long us;
-	int err = kstrtoul(buf, 0, &us);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
+	unsigned long nr;
+	int err = kstrtoul(buf, 0, &nr);
 
 	if (err)
 		return err;
 
-	intervals->sample_us = us;
+	goal->aggrs = nr;
 	return count;
 }
 
-static ssize_t aggr_us_show(struct kobject *kobj, struct kobj_attribute *attr,
-		char *buf)
+static ssize_t min_sample_us_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
 
-	return sysfs_emit(buf, "%lu\n", intervals->aggr_us);
+	return sysfs_emit(buf, "%lu\n", goal->min_sample_us);
 }
 
-static ssize_t aggr_us_store(struct kobject *kobj, struct kobj_attribute *attr,
-		const char *buf, size_t count)
+static ssize_t min_sample_us_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
-	unsigned long us;
-	int err = kstrtoul(buf, 0, &us);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
+	unsigned long nr;
+	int err = kstrtoul(buf, 0, &nr);
 
 	if (err)
 		return err;
 
-	intervals->aggr_us = us;
+	goal->min_sample_us = nr;
 	return count;
 }
 
-static ssize_t update_us_show(struct kobject *kobj,
+static ssize_t max_sample_us_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
 
-	return sysfs_emit(buf, "%lu\n", intervals->update_us);
+	return sysfs_emit(buf, "%lu\n", goal->max_sample_us);
 }
 
-static ssize_t update_us_store(struct kobject *kobj,
+static ssize_t max_sample_us_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
-	unsigned long us;
-	int err = kstrtoul(buf, 0, &us);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
+	unsigned long nr;
+	int err = kstrtoul(buf, 0, &nr);
 
 	if (err)
 		return err;
 
-	intervals->update_us = us;
+	goal->max_sample_us = nr;
 	return count;
 }
 
-static ssize_t tune_aggrs_show(struct kobject *kobj,
+static ssize_t aggr_samples_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
 
-	return sysfs_emit(buf, "%lu\n", intervals->tune_aggrs);
+	return sysfs_emit(buf, "%lu\n", goal->aggr_samples);
 }
 
-static ssize_t tune_aggrs_store(struct kobject *kobj,
+static ssize_t aggr_samples_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_intervals *intervals = container_of(kobj,
-			struct damon_sysfs_intervals, kobj);
-	unsigned long us;
-	int err = kstrtoul(buf, 0, &us);
+	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
+			struct damon_sysfs_intervals_goal, kobj);
+	unsigned long nr;
+	int err = kstrtoul(buf, 0, &nr);
 
 	if (err)
 		return err;
 
-	intervals->tune_aggrs = us;
+	goal->aggr_samples = nr;
 	return count;
 }
 
-static ssize_t target_access_samples_bp_show(struct kobject *kobj,
+static void damon_sysfs_intervals_goal_release(struct kobject *kobj)
+{
+	kfree(container_of(kobj, struct damon_sysfs_intervals_goal, kobj));
+}
+
+static struct kobj_attribute damon_sysfs_intervals_goal_samples_attr =
+		__ATTR_RW_MODE(samples, 0600);
+
+static struct kobj_attribute damon_sysfs_intervals_goal_aggrs_attr =
+		__ATTR_RW_MODE(aggrs, 0600);
+
+static struct kobj_attribute damon_sysfs_intervals_goal_min_sample_us_attr =
+		__ATTR_RW_MODE(min_sample_us, 0600);
+
+static struct kobj_attribute damon_sysfs_intervals_goal_max_sample_us_attr =
+		__ATTR_RW_MODE(max_sample_us, 0600);
+
+static struct kobj_attribute damon_sysfs_intervals_goal_aggr_samples_attr =
+		__ATTR_RW_MODE(aggr_samples, 0600);
+
+static struct attribute *damon_sysfs_intervals_goal_attrs[] = {
+	&damon_sysfs_intervals_goal_samples_attr.attr,
+	&damon_sysfs_intervals_goal_aggrs_attr.attr,
+	&damon_sysfs_intervals_goal_min_sample_us_attr.attr,
+	&damon_sysfs_intervals_goal_max_sample_us_attr.attr,
+	&damon_sysfs_intervals_goal_aggr_samples_attr.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(damon_sysfs_intervals_goal);
+
+static const struct kobj_type damon_sysfs_intervals_goal_ktype = {
+	.release = damon_sysfs_intervals_goal_release,
+	.sysfs_ops = &kobj_sysfs_ops,
+	.default_groups = damon_sysfs_intervals_goal_groups,
+};
+
+/*
+ * intervals directory
+ */
+
+struct damon_sysfs_intervals {
+	struct kobject kobj;
+	unsigned long sample_us;
+	unsigned long aggr_us;
+	unsigned long update_us;
+	struct damon_sysfs_intervals_goal *intervals_goal;
+};
+
+static struct damon_sysfs_intervals *damon_sysfs_intervals_alloc(
+		unsigned long sample_us, unsigned long aggr_us,
+		unsigned long update_us)
+{
+	struct damon_sysfs_intervals *intervals = kmalloc(sizeof(*intervals),
+			GFP_KERNEL);
+
+	if (!intervals)
+		return NULL;
+
+	intervals->kobj = (struct kobject){};
+	intervals->sample_us = sample_us;
+	intervals->aggr_us = aggr_us;
+	intervals->update_us = update_us;
+	return intervals;
+}
+
+static int damon_sysfs_intervals_add_dirs(struct damon_sysfs_intervals *intervals)
+{
+	struct damon_sysfs_intervals_goal *goal;
+	int err;
+
+	goal = damon_sysfs_intervals_goal_alloc(0, 0, 0, 0, 0);
+	if (!goal)
+		return -ENOMEM;
+
+	err = kobject_init_and_add(&goal->kobj,
+			&damon_sysfs_intervals_goal_ktype, &intervals->kobj,
+			"intervals_goal");
+	if (err) {
+		kobject_put(&goal->kobj);
+		intervals->intervals_goal = NULL;
+		return err;
+	}
+	intervals->intervals_goal = goal;
+	return 0;
+}
+
+static void damon_sysfs_intervals_rm_dirs(struct damon_sysfs_intervals *intervals)
+{
+	kobject_put(&intervals->intervals_goal->kobj);
+}
+
+static ssize_t sample_us_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
 	struct damon_sysfs_intervals *intervals = container_of(kobj,
 			struct damon_sysfs_intervals, kobj);
 
-	return sysfs_emit(buf, "%lu\n", intervals->target_access_samples_bp);
+	return sysfs_emit(buf, "%lu\n", intervals->sample_us);
 }
 
-static ssize_t target_access_samples_bp_store(struct kobject *kobj,
+static ssize_t sample_us_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
 	struct damon_sysfs_intervals *intervals = container_of(kobj,
@@ -563,21 +672,21 @@ static ssize_t target_access_samples_bp_store(struct kobject *kobj,
 	if (err)
 		return err;
 
-	intervals->target_access_samples_bp = us;
+	intervals->sample_us = us;
 	return count;
 }
 
-static ssize_t max_aggr_us_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
+static ssize_t aggr_us_show(struct kobject *kobj, struct kobj_attribute *attr,
+		char *buf)
 {
 	struct damon_sysfs_intervals *intervals = container_of(kobj,
 			struct damon_sysfs_intervals, kobj);
 
-	return sysfs_emit(buf, "%lu\n", intervals->max_aggr_us);
+	return sysfs_emit(buf, "%lu\n", intervals->aggr_us);
 }
 
-static ssize_t max_aggr_us_store(struct kobject *kobj,
-		struct kobj_attribute *attr, const char *buf, size_t count)
+static ssize_t aggr_us_store(struct kobject *kobj, struct kobj_attribute *attr,
+		const char *buf, size_t count)
 {
 	struct damon_sysfs_intervals *intervals = container_of(kobj,
 			struct damon_sysfs_intervals, kobj);
@@ -587,17 +696,32 @@ static ssize_t max_aggr_us_store(struct kobject *kobj,
 	if (err)
 		return err;
 
-	intervals->max_aggr_us = us;
+	intervals->aggr_us = us;
 	return count;
 }
 
-static ssize_t tuned_aggr_us_show(struct kobject *kobj,
+static ssize_t update_us_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
 	struct damon_sysfs_intervals *intervals = container_of(kobj,
 			struct damon_sysfs_intervals, kobj);
 
-	return sysfs_emit(buf, "%lu\n", intervals->tuned_aggr_us);
+	return sysfs_emit(buf, "%lu\n", intervals->update_us);
+}
+
+static ssize_t update_us_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	struct damon_sysfs_intervals *intervals = container_of(kobj,
+			struct damon_sysfs_intervals, kobj);
+	unsigned long us;
+	int err = kstrtoul(buf, 0, &us);
+
+	if (err)
+		return err;
+
+	intervals->update_us = us;
+	return count;
 }
 
 static void damon_sysfs_intervals_release(struct kobject *kobj)
@@ -614,27 +738,10 @@ static struct kobj_attribute damon_sysfs_intervals_aggr_us_attr =
 static struct kobj_attribute damon_sysfs_intervals_update_us_attr =
 		__ATTR_RW_MODE(update_us, 0600);
 
-static struct kobj_attribute damon_sysfs_intervals_tune_aggrs_attr =
-		__ATTR_RW_MODE(tune_aggrs, 0600);
-
-static struct kobj_attribute
-damon_sysfs_intervals_target_access_samples_bp_attr =
-		__ATTR_RW_MODE(target_access_samples_bp, 0600);
-
-static struct kobj_attribute damon_sysfs_intervals_max_aggr_us_attr =
-		__ATTR_RW_MODE(max_aggr_us, 0600);
-
-static struct kobj_attribute damon_sysfs_intervals_tuned_aggr_us_attr =
-		__ATTR_RO_MODE(tuned_aggr_us, 0400);
-
 static struct attribute *damon_sysfs_intervals_attrs[] = {
 	&damon_sysfs_intervals_sample_us_attr.attr,
 	&damon_sysfs_intervals_aggr_us_attr.attr,
 	&damon_sysfs_intervals_update_us_attr.attr,
-	&damon_sysfs_intervals_tune_aggrs_attr.attr,
-	&damon_sysfs_intervals_target_access_samples_bp_attr.attr,
-	&damon_sysfs_intervals_max_aggr_us_attr.attr,
-	&damon_sysfs_intervals_tuned_aggr_us_attr.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(damon_sysfs_intervals);
@@ -678,6 +785,9 @@ static int damon_sysfs_attrs_add_dirs(struct damon_sysfs_attrs *attrs)
 	err = kobject_init_and_add(&intervals->kobj,
 			&damon_sysfs_intervals_ktype, &attrs->kobj,
 			"intervals");
+	if (err)
+		goto put_intervals_out;
+	err = damon_sysfs_intervals_add_dirs(intervals);
 	if (err)
 		goto put_intervals_out;
 	attrs->intervals = intervals;
@@ -708,6 +818,7 @@ static int damon_sysfs_attrs_add_dirs(struct damon_sysfs_attrs *attrs)
 static void damon_sysfs_attrs_rm_dirs(struct damon_sysfs_attrs *attrs)
 {
 	kobject_put(&attrs->nr_regions_range->kobj);
+	damon_sysfs_intervals_rm_dirs(attrs->intervals);
 	kobject_put(&attrs->intervals->kobj);
 }
 
@@ -1207,10 +1318,6 @@ static int damon_sysfs_set_attrs(struct damon_ctx *ctx,
 		.ops_update_interval = sys_intervals->update_us,
 		.min_nr_regions = sys_nr_regions->min,
 		.max_nr_regions = sys_nr_regions->max,
-		.tune_interval_aggrs = sys_intervals->tune_aggrs,
-		.target_access_samples_bp =
-			sys_intervals->target_access_samples_bp,
-		.max_aggr_interval = sys_intervals->max_aggr_us,
 	};
 	return damon_set_attrs(ctx, &attrs);
 }
@@ -1438,8 +1545,10 @@ static int damon_sysfs_upd_tuned_aggr_us(void *data)
 	struct damon_sysfs_kdamond *kdamond = data;
 	struct damon_ctx *ctx = kdamond->damon_ctx;
 
-	kdamond->contexts->contexts_arr[0]->attrs->intervals->max_aggr_us =
-		ctx->attrs.max_aggr_interval;
+	kdamond->contexts->contexts_arr[0]->attrs->intervals->sample_us =
+		ctx->attrs.sample_interval;
+	kdamond->contexts->contexts_arr[0]->attrs->intervals->aggr_us =
+		ctx->attrs.aggr_interval;
 	return 0;
 }
 
-- 
2.39.5

