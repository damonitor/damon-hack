From: SeongJae Park <sj@kernel.org>
Date: Tue, 28 Jan 2025 19:56:12 -0800
Subject: [PATCH] mm/damon: move aggr_samples to attrs's privat field

In long term, it should replace aggr_interval.  But, for now, keep it as
a hidden field.  It is set when core-external code calls set_attrs().
When core-internal code calls set_attrs(), previously set value is kept.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h | 19 ++++++++++++++-----
 mm/damon/core.c       | 10 ++++++----
 mm/damon/sysfs.c      | 38 +++-----------------------------------
 3 files changed, 23 insertions(+), 44 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index c3e9431c3e4c..0ba09599691c 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -676,15 +676,14 @@ struct damon_call_control {
  * @aggrs:		Number of aggregations to acheive @samples within.
  * @min_sample_us:	Minimum resulting sampling interval in microseconds.
  * @max_sample_us:	Maximum resulting sampling interval in microseconds.
- * @aggr_samples:	Aggregation to sample interval ratio.
  *
  * DAMON automatically tunes &damon_attrs->sample_interval and
  * &damon_attrs->aggr_interval aiming the number of access check samples that
  * shown positive result (was accessed) within @aggrs aggregations be same to
  * @samples.  The logic increases &damon_attrs->aggr_interval and
- * &damon_attrs->sampling_interval in same ratio (@aggr_samples) if the current
- * positive access samples ratio is lower than the target for each @aggrs
- * aggregations, and vice versa.
+ * &damon_attrs->sampling_interval in same ratio if the current positive access
+ * samples ratio is lower than the target for each @aggrs aggregations, and
+ * vice versa.
  *
  * If @aggrs is zero, the tuning is disabled.  If any input makes no sense
  * (e.g., @min_sample_us is samller than @max_sample_us, or
@@ -696,7 +695,6 @@ struct damon_intervals_goal {
 	unsigned long aggrs;
 	unsigned long min_sample_us;
 	unsigned long max_sample_us;
-	unsigned long aggr_samples;
 };
 
 /**
@@ -728,6 +726,17 @@ struct damon_attrs {
 	struct damon_intervals_goal intervals_goal;
 	unsigned long min_nr_regions;
 	unsigned long max_nr_regions;
+/* private: internal use only */
+	/*
+	 * @aggr_interval to @sample_interval ratio.
+	 * Core-external components call damon_set_attrs() with &damon_attrs
+	 * that this field is unset.  In the case, damon_set_attrs() sets this
+	 * field of resulting &damon_attrs.  Core-internal components such as
+	 * kdamond_tune_intervals() calls damon_set_attrs() with &damon_attrs
+	 * that this field is set.  In the case, damon_set_attrs() just keep
+	 * it.
+	 */
+	unsigned long aggr_samples;
 };
 
 /**
diff --git a/mm/damon/core.c b/mm/damon/core.c
index bd341aa464a5..07eec15d730d 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -660,8 +660,6 @@ static bool damon_valid_intervals_goal(struct damon_attrs *attrs)
 	if (attrs->sample_interval < goal->min_sample_us ||
 			goal->max_sample_us < attrs->sample_interval)
 		return false;
-	if (!goal->aggr_samples)
-		return false;
 	return true;
 }
 
@@ -695,6 +693,10 @@ int damon_set_attrs(struct damon_ctx *ctx, struct damon_attrs *attrs)
 	if (attrs->sample_interval > attrs->aggr_interval)
 		return -EINVAL;
 
+	/* Only calls from core-external doesn't set this. */
+	if (!attrs->aggr_samples)
+		attrs->aggr_samples = attrs->aggr_interval / sample_interval;
+
 	ctx->next_aggregation_sis = ctx->passed_sample_intervals +
 		attrs->aggr_interval / sample_interval;
 	ctx->next_ops_update_sis = ctx->passed_sample_intervals +
@@ -1371,7 +1373,7 @@ static void kdamond_tune_intervals(struct damon_ctx *c)
 	new_attrs.sample_interval = max(new_attrs.sample_interval,
 			goal->min_sample_us);
 	new_attrs.aggr_interval = new_attrs.sample_interval *
-		goal->aggr_samples;
+		c->attrs.aggr_samples;
 
 	pr_info("tune intervals to %lu %lu\n\n",
 			new_attrs.sample_interval, new_attrs.aggr_interval);
@@ -2405,7 +2407,7 @@ static int kdamond_fn(void *data)
 					ctx->passed_sample_intervals >=
 					ctx->next_intervals_tune_sis) {
 				ctx->next_intervals_tune_sis +=
-					ctx->attrs.intervals_goal.aggr_samples * 
+					ctx->attrs.aggr_samples *
 					ctx->attrs.intervals_goal.aggrs;
 				kdamond_tune_intervals(ctx);
 			}
diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index 768c854d3ab0..9ae755bc31de 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -418,13 +418,11 @@ struct damon_sysfs_intervals_goal {
 	unsigned long aggrs;
 	unsigned long min_sample_us;
 	unsigned long max_sample_us;
-	unsigned long aggr_samples;
 };
 
 static struct damon_sysfs_intervals_goal *damon_sysfs_intervals_goal_alloc(
 		unsigned long samples, unsigned long aggrs,
-		unsigned long min_sample_us, unsigned long max_sample_us,
-		unsigned long aggr_samples)
+		unsigned long min_sample_us, unsigned long max_sample_us)
 {
 	struct damon_sysfs_intervals_goal *goal = kmalloc(sizeof(*goal),
 			GFP_KERNEL);
@@ -437,7 +435,6 @@ static struct damon_sysfs_intervals_goal *damon_sysfs_intervals_goal_alloc(
 	goal->aggrs = aggrs;
 	goal->min_sample_us = min_sample_us;
 	goal->max_sample_us = max_sample_us;
-	goal->aggr_samples = aggr_samples;
 	return goal;
 }
 
@@ -537,30 +534,6 @@ static ssize_t max_sample_us_store(struct kobject *kobj,
 	return count;
 }
 
-static ssize_t aggr_samples_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
-{
-	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
-			struct damon_sysfs_intervals_goal, kobj);
-
-	return sysfs_emit(buf, "%lu\n", goal->aggr_samples);
-}
-
-static ssize_t aggr_samples_store(struct kobject *kobj,
-		struct kobj_attribute *attr, const char *buf, size_t count)
-{
-	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
-			struct damon_sysfs_intervals_goal, kobj);
-	unsigned long nr;
-	int err = kstrtoul(buf, 0, &nr);
-
-	if (err)
-		return err;
-
-	goal->aggr_samples = nr;
-	return count;
-}
-
 static void damon_sysfs_intervals_goal_release(struct kobject *kobj)
 {
 	kfree(container_of(kobj, struct damon_sysfs_intervals_goal, kobj));
@@ -578,15 +551,11 @@ static struct kobj_attribute damon_sysfs_intervals_goal_min_sample_us_attr =
 static struct kobj_attribute damon_sysfs_intervals_goal_max_sample_us_attr =
 		__ATTR_RW_MODE(max_sample_us, 0600);
 
-static struct kobj_attribute damon_sysfs_intervals_goal_aggr_samples_attr =
-		__ATTR_RW_MODE(aggr_samples, 0600);
-
 static struct attribute *damon_sysfs_intervals_goal_attrs[] = {
 	&damon_sysfs_intervals_goal_samples_attr.attr,
 	&damon_sysfs_intervals_goal_aggrs_attr.attr,
 	&damon_sysfs_intervals_goal_min_sample_us_attr.attr,
 	&damon_sysfs_intervals_goal_max_sample_us_attr.attr,
-	&damon_sysfs_intervals_goal_aggr_samples_attr.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(damon_sysfs_intervals_goal);
@@ -631,7 +600,7 @@ static int damon_sysfs_intervals_add_dirs(struct damon_sysfs_intervals *interval
 	struct damon_sysfs_intervals_goal *goal;
 	int err;
 
-	goal = damon_sysfs_intervals_goal_alloc(0, 0, 0, 0, 0);
+	goal = damon_sysfs_intervals_goal_alloc(0, 0, 0, 0);
 	if (!goal)
 		return -ENOMEM;
 
@@ -1321,8 +1290,7 @@ static int damon_sysfs_set_attrs(struct damon_ctx *ctx,
 			.samples = sys_goal->samples,
 			.aggrs = sys_goal->aggrs,
 			.min_sample_us = sys_goal->min_sample_us,
-			.max_sample_us = sys_goal->max_sample_us,
-			.aggr_samples = sys_goal->aggr_samples},
+			.max_sample_us = sys_goal->max_sample_us},
 		.ops_update_interval = sys_intervals->update_us,
 		.min_nr_regions = sys_nr_regions->min,
 		.max_nr_regions = sys_nr_regions->max,
-- 
2.39.5

