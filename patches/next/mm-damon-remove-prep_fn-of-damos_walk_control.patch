From: SeongJae Park <sj@kernel.org>
Date: Fri, 13 Dec 2024 11:50:39 -0800
Subject: [PATCH] mm/damon: remove prep_fn of damos_walk_control

It is not really being used.  Remove.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h | 10 +++------
 mm/damon/core.c       | 48 ++++++++++++-------------------------------
 mm/damon/sysfs.c      |  1 -
 3 files changed, 16 insertions(+), 43 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index e9101708e56d..bf3ea3030e90 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -375,16 +375,14 @@ struct damos;
 /**
  * struct damos_walk_control - Control damos_walk().
  *
- * @prep_fn:	Function to be called back once before @walk_fn.
  * @walk_fn:	Function to be called back for each region.
  * @data:	Data that will be passed to walk functions.
  *
- * Control damos_walk(), which requests specific kdamond to invoke given
- * functions before the actions of the kdamond's schemes are applied for each
- * region.  Refer to damos_walk() for more details.
+ * Control damos_walk(), which requests specific kdamond to invoke the given
+ * function to each region that eligible to apply actions of the kdamond's
+ * schemes.  Refer to damos_walk() for more details.
  */
 struct damos_walk_control {
-	void (*prep_fn)(void *data, struct damon_ctx *ctx);
 	void (*walk_fn)(void *data, struct damon_ctx *ctx,
 			struct damon_target *t, struct damon_region *r,
 			struct damos *s);
@@ -392,8 +390,6 @@ struct damos_walk_control {
 /* private: internal use only */
 	/* informs if the kdamond finished handling of the walk reqeust */
 	struct completion completion;
-	/* informs if @prep_fn has called */
-	bool prep_done;
 	/* informs if the walk is canceled. */
 	bool canceled;
 };
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 00d266624ea0..6e0c1e067c45 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -1234,26 +1234,29 @@ int damon_call(struct damon_ctx *ctx, struct damon_call_control *control)
 }
 
 /**
- * damos_walk() - Invoke given functions for regions that DAMOS will be applied.
+ * damos_walk() - Invoke a given functions while DAMOS walk regions.
  * @ctx:	DAMON context to call the functions for.
  * @control:	Control variable of the walk request.
  *
- * Similar to damon_call(), ask the kdamond of @ctx to invoke given functions
- * and wait until the kdamond finishes handling of the request.
+ * Ask DAMON worker thread (kdamond) of @ctx to call a function for each region
+ * that the kdamond will apply DAMOS action to, and wait until the kdamond
+ * finishes handling of the request.
  *
- * The kdamond executes the functions with the argument in the main loop, just
- * before applying DAMOS actions of @ctx to each region.  The function can
- * hence safely access the internal data of &struct damon_ctx without
- * additional synchronization.  Also it can directly access to regions that
- * finally DAMOS schemes of @ctx will be applied for next
- * &damos->apply_interval_us.
+ * The kdamond executes the given function in the main loop, for each region
+ * just before it applies any DAMOS actions of @ctx to it.  The invocation is
+ * made only within one &damos->apply_interval_us since damos_walk()
+ * invocation, for each scheme.  The given callback function can hence safely
+ * access the internal data of &struct damon_ctx and &struct damo_region that
+ * each of the scheme will apply the action for next interval, without
+ * additional synchronizations against the kdamond.  If every scheme of @ctx
+ * passed at least one &damos->apply_interval_us, kdamond marks the request as
+ * completed so that damos_walk() can wakeup and return.
  *
  * Return: 0 on success, negative error code otherwise.
  */
 int damos_walk(struct damon_ctx *ctx, struct damos_walk_control *control)
 {
 	init_completion(&control->completion);
-	control->prep_done = false;
 	control->canceled = false;
 	mutex_lock(&ctx->walk_control_lock);
 	if (ctx->walk_control) {
@@ -1449,30 +1452,6 @@ static bool damos_filter_out(struct damon_ctx *ctx, struct damon_target *t,
 	return false;
 }
 
-/*
- * damos_walk_call_prep() - Call &damos_walk_control->prep_fn if needed.
- * @ctx:	The context of &damon_ctx->walk_control.
- *
- * This function is called when kdamond found a scheme that passed its
- * &damos->apply_interval_us and therefore ready to apply the scheme's action
- * to eligible regions.  If a DAMOS walk request is installed by damos_walk()
- * and its &damos_walk_control->prep_fn has not invoked at all, invoke it.
- */
-static void damos_walk_call_prep(struct damon_ctx *ctx)
-{
-	struct damos_walk_control *control;
-
-	mutex_lock(&ctx->walk_control_lock);
-	control = ctx->walk_control;
-	mutex_unlock(&ctx->walk_control_lock);
-	if (!control)
-		return;
-	if (control->prep_done)
-		return;
-	control->prep_fn(control->data, ctx);
-	control->prep_done = true;
-}
-
 /*
  * damos_walk_call_walk() - Call &damos_walk_control->walk_fn.
  * @ctx:	The context of &damon_ctx->walk_control.
@@ -1880,7 +1859,6 @@ static void kdamond_apply_schemes(struct damon_ctx *c)
 			continue;
 
 		has_schemes_to_apply = true;
-		damos_walk_call_prep(c);
 
 		damos_adjust_quota(c, s);
 	}
diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index fa494c48c6f6..7c4ed90b7bd0 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -1489,7 +1489,6 @@ static int damon_sysfs_update_schemes_tried_regions(
 		.total_bytes_only = total_bytes_only,
 	};
 	struct damos_walk_control control = {
-		.prep_fn = NULL,
 		.walk_fn = damon_sysfs_schemes_tried_regions_upd_one,
 		.data = &walk_data,
 	};
-- 
2.39.5

