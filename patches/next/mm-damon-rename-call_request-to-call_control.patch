From: SeongJae Park <sj@kernel.org>
Date: Fri, 22 Nov 2024 13:53:55 -0800
Subject: [PATCH] mm/damon: rename call_request to call_control

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h | 11 ++++++-----
 mm/damon/core.c       | 32 ++++++++++++++++----------------
 mm/damon/sysfs.c      | 20 ++++++++++----------
 3 files changed, 32 insertions(+), 31 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index c4bcc3ae2d7b..30fbe73849ea 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -595,19 +595,20 @@ struct damon_callback {
 };
 
 /*
- * struct damon_call_req - Request for damon_call().
+ * struct damon_call_control - Control DAMON worker thread callback.
  *
  * @fn:			Function to be called back from DAMON.
  * @arg:		Argument that will be passed to @fn.
  * @return_code:	Return code from @fn.
  */
-struct damon_call_req {
+struct damon_call_control {
 	int (*fn)(void *arg);
 	void *arg;
 	int return_code;
 /* private: internal use only */
 	/* for waiting on DAMON's @fn invocation completion. */
 	struct completion completion;
+	/* for saving if the request is canceled. */
 	bool canceled;
 };
 
@@ -691,8 +692,8 @@ struct damon_ctx {
 	/* for scheme quotas prioritization */
 	unsigned long *regions_score_histogram;
 
-	struct damon_call_req *call_request;
-	struct mutex call_request_lock;
+	struct damon_call_control *call_control;
+	struct mutex call_control_lock;
 
 #ifdef DAMON_WIP
 	struct damos_walk_control *walk_control;
@@ -846,7 +847,7 @@ static inline unsigned int damon_max_nr_accesses(const struct damon_attrs *attrs
 int damon_start(struct damon_ctx **ctxs, int nr_ctxs, bool exclusive);
 int damon_stop(struct damon_ctx **ctxs, int nr_ctxs);
 
-int damon_call(struct damon_ctx *ctx, struct damon_call_req *req);
+int damon_call(struct damon_ctx *ctx, struct damon_call_control *control);
 
 int damon_set_region_biggest_system_ram_default(struct damon_target *t,
 				unsigned long *start, unsigned long *end);
diff --git a/mm/damon/core.c b/mm/damon/core.c
index aae2606b54d7..ab4699e83c30 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -533,7 +533,7 @@ struct damon_ctx *damon_new_ctx(void)
 	ctx->next_ops_update_sis = 0;
 
 	mutex_init(&ctx->kdamond_lock);
-	mutex_init(&ctx->call_request_lock);
+	mutex_init(&ctx->call_ctonrol_lock);
 #ifdef DAMON_WIP
 	mutex_init(&ctx->walk_control_lock);
 #endif
@@ -1203,21 +1203,21 @@ int damon_stop(struct damon_ctx **ctxs, int nr_ctxs)
  *
  * Return: 0 on success, negative error code otherwise.
  */
-int damon_call(struct damon_ctx *ctx, struct damon_call_req *req)
+int damon_call(struct damon_ctx *ctx, struct damon_call_control *control)
 {
 	init_completion(&req->completion);
 	req->canceld = false;
 
-	mutex_lock(&ctx->call_request_lock);
-	if (ctx->call_request) {
-		mutex_unlock(&ctx->call_request_lock);
+	mutex_lock(&ctx->call_control_lock);
+	if (ctx->call_control) {
+		mutex_unlock(&ctx->call_control_lock);
 		return -EBUSY;
 	}
-	ctx->call_request = req;
-	mutex_unlock(&ctx->call_request_lock);
+	ctx->call_control = control;
+	mutex_unlock(&ctx->call_control_lock);
 
-	wait_for_completion(&req->completion);
-	if (req->canceled)
+	wait_for_completion(&control->completion);
+	if (control->canceled)
 		return -ECANCELED;
 	return 0;
 }
@@ -2120,12 +2120,12 @@ static void kdamond_usleep(unsigned long usecs)
 
 static void kdamond_callback(struct damon_ctx *ctx, bool cancel)
 {
-	struct damon_call_req *req;
+	struct damon_call_control *control;
 	int ret = 0;
 
-	mutex_lock(&ctx->call_request_lock);
-	req = ctx->call_request;
-	mutex_unlock(&ctx->call_request_lock);
+	mutex_lock(&ctx->call_control_lock);
+	req = ctx->call_control;
+	mutex_unlock(&ctx->call_control_lock);
 	if (!req)
 		return;
 	if (cancel) {
@@ -2135,9 +2135,9 @@ static void kdamond_callback(struct damon_ctx *ctx, bool cancel)
 		req->return_code = ret;
 	}
 	complete(&req->completion);
-	mutex_lock(&ctx->call_request_lock);
-	ctx->call_request = NULL;
-	mutex_unlock(&ctx->call_request_lock);
+	mutex_lock(&ctx->call_control_lock);
+	ctx->call_control = NULL;
+	mutex_unlock(&ctx->call_control_lock);
 }
 
 /* Returns negative error code if it's not activated but should return */
diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index b1aeca32d2bf..d80713eaca55 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -1541,7 +1541,7 @@ static int damon_sysfs_handle_cmd(enum damon_sysfs_cmd cmd,
 		struct damon_sysfs_kdamond *kdamond)
 {
 	bool need_wait = true;
-	struct damon_call_req call_req = {};
+	struct damon_call_control call_control = {};
 #ifdef DAMON_WIP
 	struct damos_walk_control walk_control;
 	struct damos_sysfs_regions_walk_arg walk_arg = {
@@ -1560,17 +1560,17 @@ static int damon_sysfs_handle_cmd(enum damon_sysfs_cmd cmd,
 	case DAMON_SYSFS_CMD_OFF:
 		return damon_sysfs_turn_damon_off(kdamond);
 	case DAMON_SYSFS_CMD_UPDATE_SCHEMES_STATS:
-		call_req.fn = damon_sysfs_upd_schemes_stats;
-		call_req.arg = kdamond;
-		return damon_call(kdamond->damon_ctx, &call_req);
+		call_control.fn = damon_sysfs_upd_schemes_stats;
+		call_control.arg = kdamond;
+		return damon_call(kdamond->damon_ctx, &call_control);
 	case DAMON_SYSFS_CMD_COMMIT_SCHEMES_QUOTA_GOALS:
-		call_req.fn = damon_sysfs_commit_schemes_quota_goals;
-		call_req.arg = kdamond;
-		return damon_call(kdamond->damon_ctx, &call_req);
+		call_control.fn = damon_sysfs_commit_schemes_quota_goals;
+		call_control.arg = kdamond;
+		return damon_call(kdamond->damon_ctx, &call_control);
 	case DAMON_SYSFS_CMD_CLEAR_SCHEMES_TRIED_REGIONS:
-		call_req.fn = damon_sysfs_clear_schemes_regions;
-		call_req.arg = kdamond;
-		return damon_call(kdamond->damon_ctx, &call_req);
+		call_control.fn = damon_sysfs_clear_schemes_regions;
+		call_control.arg = kdamond;
+		return damon_call(kdamond->damon_ctx, &call_control);
 #ifdef DAMON_WIP
 	case DAMON_SYSFS_CMD_UPDATE_SCHEMES_TRIED_BYTES:
 		walk_arg.total_bytes_only = true;
-- 
2.39.5

