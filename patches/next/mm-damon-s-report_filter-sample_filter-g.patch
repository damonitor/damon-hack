From: SeongJae Park <sj@kernel.org>
Date: Sun, 30 Nov 2025 08:36:01 -0800
Subject: [PATCH] mm/damon: s/report_filter/sample_filter/g

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h |  34 +++----
 mm/damon/core.c       |  68 +++++++-------
 mm/damon/sysfs.c      | 202 +++++++++++++++++++++---------------------
 3 files changed, 152 insertions(+), 152 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index e1cb8ec668e5..b901a11ee06f 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -811,20 +811,20 @@ struct damon_primitives_enabled {
 };
 
 /**
- * enum damon_report_filter_type - Type of &struct damon_access_report to
+ * enum damon_sample_filter_type - Type of &struct damon_access_report to
  * filter.
  * @DAMON_FILTER_TYPE_CPUMASK:	Access-generated CPUs.
  * @DAMON_FILTER_TYPE_THREADS:	Access-generated threads.
  * @DAMON_FILTER_TYPE_WRITE:	Whether the access was for writing.
  */
-enum damon_report_filter_type {
+enum damon_sample_filter_type {
 	DAMON_FILTER_TYPE_CPUMASK,
 	DAMON_FILTER_TYPE_THREADS,
 	DAMON_FILTER_TYPE_WRITE,
 };
 
 /**
- * struct damon_report_filter - &struct damon_access_report filter.
+ * struct damon_sample_filter - &struct damon_access_report filter.
  * @type:	The type of this filter.
  * @matching:	Whether it is for condition-matching reports.
  * @allow:	Whether to include or excludie the @matching reports.
@@ -834,8 +834,8 @@ enum damon_report_filter_type {
  * @nr_tids:	Size of @tid_arr, if @type is DAMON_FILTER_TYPE_THREADS.
  * @list:	List head for siblings.
  */
-struct damon_report_filter {
-	enum damon_report_filter_type type;
+struct damon_sample_filter {
+	enum damon_sample_filter_type type;
 	bool matching;
 	bool allow;
 	union {
@@ -851,11 +851,11 @@ struct damon_report_filter {
 /**
  * struct damon_sample_control - Low level access check sampling rules.
  * @primitives_enabled:	Enablement of access check primitives.
- * @report_filters:		List of added access check report filters.
+ * @sample_filters:		List of added access check report filters.
  */
 struct damon_sample_control {
 	struct damon_primitives_enabled primitives_enabled;
-	struct list_head report_filters;
+	struct list_head sample_filters;
 };
 
 /**
@@ -976,11 +976,11 @@ static inline unsigned long damon_sz_region(struct damon_region *r)
 #define damon_for_each_target_safe(t, next, ctx)	\
 	list_for_each_entry_safe(t, next, &(ctx)->adaptive_targets, list)
 
-#define damon_for_each_report_filter(f, control) \
-	list_for_each_entry(f, &control->report_filters, list)
+#define damon_for_each_sample_filter(f, control) \
+	list_for_each_entry(f, &control->sample_filters, list)
 
-#define damon_for_each_report_filter_safe(f, next, control) \
-	list_for_each_entry_safe(f, next, &control->report_filters, list)
+#define damon_for_each_sample_filter_safe(f, next, control) \
+	list_for_each_entry_safe(f, next, &control->sample_filters, list)
 
 #define damon_for_each_scheme(s, ctx) \
 	list_for_each_entry(s, &(ctx)->schemes, list)
@@ -1057,13 +1057,13 @@ void damon_free_target(struct damon_target *t);
 void damon_destroy_target(struct damon_target *t, struct damon_ctx *ctx);
 unsigned int damon_nr_regions(struct damon_target *t);
 
-struct damon_report_filter *damon_new_report_filter(
-		enum damon_report_filter_type filter_type, bool matching,
+struct damon_sample_filter *damon_new_sample_filter(
+		enum damon_sample_filter_type filter_type, bool matching,
 		bool allow);
-void damon_add_report_filter(struct damon_sample_control *ctrl,
-		struct damon_report_filter *filter);
-void damon_free_report_filter(struct damon_report_filter *filter);
-void damon_destroy_report_filter(struct damon_report_filter *filter,
+void damon_add_sample_filter(struct damon_sample_control *ctrl,
+		struct damon_sample_filter *filter);
+void damon_free_sample_filter(struct damon_sample_filter *filter);
+void damon_destroy_sample_filter(struct damon_sample_filter *filter,
 		struct damon_sample_control *ctrl);
 
 struct damon_ctx *damon_new_ctx(void);
diff --git a/mm/damon/core.c b/mm/damon/core.c
index dbec75dac064..8c50f6cb4294 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -533,11 +533,11 @@ unsigned int damon_nr_regions(struct damon_target *t)
 	return t->nr_regions;
 }
 
-struct damon_report_filter *damon_new_report_filter(
-		enum damon_report_filter_type filter_type, bool matching,
+struct damon_sample_filter *damon_new_sample_filter(
+		enum damon_sample_filter_type filter_type, bool matching,
 		bool allow)
 {
-	struct damon_report_filter *filter;
+	struct damon_sample_filter *filter;
 
 	filter = kmalloc(sizeof(*filter), GFP_KERNEL);
 	if (!filter)
@@ -553,41 +553,41 @@ struct damon_report_filter *damon_new_report_filter(
 	return filter;
 }
 
-void damon_add_report_filter(struct damon_sample_control *ctrl,
-		struct damon_report_filter *filter)
+void damon_add_sample_filter(struct damon_sample_control *ctrl,
+		struct damon_sample_filter *filter)
 {
-	list_add_tail(&filter->list, &ctrl->report_filters);
+	list_add_tail(&filter->list, &ctrl->sample_filters);
 }
 
-static void damon_del_report_filter(struct damon_report_filter *f,
+static void damon_del_sample_filter(struct damon_sample_filter *f,
 		struct damon_sample_control *ctrl)
 {
 	list_del(&f->list);
 }
 
-void damon_free_report_filter(struct damon_report_filter *f)
+void damon_free_sample_filter(struct damon_sample_filter *f)
 {
 	kfree(f);
 }
 
-void damon_destroy_report_filter(struct damon_report_filter *f,
+void damon_destroy_sample_filter(struct damon_sample_filter *f,
 		struct damon_sample_control *ctrl)
 {
-	damon_del_report_filter(f, ctrl);
+	damon_del_sample_filter(f, ctrl);
 	if (f->type == DAMON_FILTER_TYPE_THREADS) {
 		kfree(f->tid_arr);
 		f->nr_tids = 0;
 	}
-	damon_free_report_filter(f);
+	damon_free_sample_filter(f);
 }
 
-static struct damon_report_filter *damon_nth_report_filter(int n,
+static struct damon_sample_filter *damon_nth_sample_filter(int n,
 		struct damon_sample_control *ctrl)
 {
-	struct damon_report_filter *f;
+	struct damon_sample_filter *f;
 	int i = 0;
 
-	damon_for_each_report_filter(f, ctrl) {
+	damon_for_each_sample_filter(f, ctrl) {
 		if (i++ == n)
 			return f;
 	}
@@ -622,7 +622,7 @@ struct damon_ctx *damon_new_ctx(void)
 	ctx->attrs.max_nr_regions = 1000;
 
 	ctx->sample_control.primitives_enabled.page_table = true;
-	INIT_LIST_HEAD(&ctx->sample_control.report_filters);
+	INIT_LIST_HEAD(&ctx->sample_control.sample_filters);
 
 	ctx->addr_unit = 1;
 	ctx->min_sz_region = DAMON_MIN_REGION;
@@ -644,16 +644,16 @@ static void damon_destroy_targets(struct damon_ctx *ctx)
 void damon_destroy_ctx(struct damon_ctx *ctx)
 {
 	struct damos *s, *next_s;
-	struct damon_report_filter *f, *next_f;
+	struct damon_sample_filter *f, *next_f;
 
 	damon_destroy_targets(ctx);
 
 	damon_for_each_scheme_safe(s, next_s, ctx)
 		damon_destroy_scheme(s);
 
-	damon_for_each_report_filter_safe(f, next_f,
+	damon_for_each_sample_filter_safe(f, next_f,
 			(&ctx->sample_control))
-		damon_destroy_report_filter(f, &ctx->sample_control);
+		damon_destroy_sample_filter(f, &ctx->sample_control);
 
 	if (ctx->ops_attrs.nr_tids)
 		kfree(ctx->ops_attrs.tids);
@@ -1315,8 +1315,8 @@ static int damon_commit_targets(
 	return 0;
 }
 
-static int damon_commit_report_filter_arg(struct damon_report_filter *dst,
-		struct damon_report_filter *src)
+static int damon_commit_sample_filter_arg(struct damon_sample_filter *dst,
+		struct damon_sample_filter *src)
 {
 	switch (src->type) {
 	case DAMON_FILTER_TYPE_CPUMASK:
@@ -1341,12 +1341,12 @@ static int damon_commit_report_filter_arg(struct damon_report_filter *dst,
 	return 0;
 }
 
-static int damon_commit_report_filter(struct damon_report_filter *dst,
-		struct damon_report_filter *src)
+static int damon_commit_sample_filter(struct damon_sample_filter *dst,
+		struct damon_sample_filter *src)
 {
 	int err;
 
-	err = damon_commit_report_filter_arg(dst, src);
+	err = damon_commit_sample_filter_arg(dst, src);
 	if (err)
 		return err;
 	dst->matching = src->matching;
@@ -1354,37 +1354,37 @@ static int damon_commit_report_filter(struct damon_report_filter *dst,
 	return 0;
 }
 
-static int damon_commit_report_filters(struct damon_sample_control *dst,
+static int damon_commit_sample_filters(struct damon_sample_control *dst,
 		struct damon_sample_control *src)
 {
-	struct damon_report_filter *dst_filter, *next, *src_filter, *new_filter;
+	struct damon_sample_filter *dst_filter, *next, *src_filter, *new_filter;
 	int i = 0, j = 0, err;
 
-	damon_for_each_report_filter_safe(dst_filter, next, dst) {
-		src_filter = damon_nth_report_filter(i++, src);
+	damon_for_each_sample_filter_safe(dst_filter, next, dst) {
+		src_filter = damon_nth_sample_filter(i++, src);
 		if (src_filter) {
-			err = damon_commit_report_filter(dst_filter,
+			err = damon_commit_sample_filter(dst_filter,
 					src_filter);
 			if (err)
 				return err;
 		} else {
-			damon_destroy_report_filter(dst_filter, dst);
+			damon_destroy_sample_filter(dst_filter, dst);
 		}
 	}
 
-	damon_for_each_report_filter_safe(src_filter, next, src) {
+	damon_for_each_sample_filter_safe(src_filter, next, src) {
 		if (j++ < i)
 			continue;
 
-		new_filter = damon_new_report_filter(
+		new_filter = damon_new_sample_filter(
 				src_filter->type, src_filter->matching,
 				src_filter->allow);
 		if (!new_filter)
 			return -ENOMEM;
-		err = damon_commit_report_filter_arg(new_filter, src_filter);
+		err = damon_commit_sample_filter_arg(new_filter, src_filter);
 		if (err)
 			return err;
-		damon_add_report_filter(dst, new_filter);
+		damon_add_sample_filter(dst, new_filter);
 	}
 	return 0;
 }
@@ -1403,7 +1403,7 @@ static int damon_commit_sample_control(
 		return -EINVAL;
 
 	dst->primitives_enabled = src->primitives_enabled;
-	return damon_commit_report_filters(dst, src);
+	return damon_commit_sample_filters(dst, src);
 }
 
 /**
diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index 0cdaa58d2e4f..014404e4b679 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -753,27 +753,27 @@ static const struct kobj_type damon_sysfs_intervals_ktype = {
  * access check report filter directory
  */
 
-struct damon_sysfs_report_filter {
+struct damon_sysfs_sample_filter {
 	struct kobject kobj;
-	enum damon_report_filter_type type;
+	enum damon_sample_filter_type type;
 	bool matching;
 	bool allow;
 	cpumask_t cpumask;
 	int *tid_arr;	/* first entry is the length of the array */
 };
 
-static struct damon_sysfs_report_filter *damon_sysfs_report_filter_alloc(void)
+static struct damon_sysfs_sample_filter *damon_sysfs_sample_filter_alloc(void)
 {
-	return kzalloc(sizeof(struct damon_sysfs_report_filter), GFP_KERNEL);
+	return kzalloc(sizeof(struct damon_sysfs_sample_filter), GFP_KERNEL);
 }
 
-struct damon_sysfs_report_filter_type_name {
-	enum damon_report_filter_type type;
+struct damon_sysfs_sample_filter_type_name {
+	enum damon_sample_filter_type type;
 	char *name;
 };
 
-static const struct damon_sysfs_report_filter_type_name
-damon_sysfs_report_filter_type_names[] = {
+static const struct damon_sysfs_sample_filter_type_name
+damon_sysfs_sample_filter_type_names[] = {
 	{
 		.type = DAMON_FILTER_TYPE_CPUMASK,
 		.name = "cpumask",
@@ -787,14 +787,14 @@ damon_sysfs_report_filter_type_names[] = {
 static ssize_t type_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 	int i = 0;
 
-	for (; i < ARRAY_SIZE(damon_sysfs_report_filter_type_names); i++) {
-		const struct damon_sysfs_report_filter_type_name *type_name;
+	for (; i < ARRAY_SIZE(damon_sysfs_sample_filter_type_names); i++) {
+		const struct damon_sysfs_sample_filter_type_name *type_name;
 
-		type_name = &damon_sysfs_report_filter_type_names[i];
+		type_name = &damon_sysfs_sample_filter_type_names[i];
 		if (type_name->type == filter->type)
 			return sysfs_emit(buf, "%s\n", type_name->name);
 	}
@@ -804,15 +804,15 @@ static ssize_t type_show(struct kobject *kobj,
 static ssize_t type_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 	ssize_t ret = -EINVAL;
 	int i = 0;
 
-	for (; i < ARRAY_SIZE(damon_sysfs_report_filter_type_names); i++) {
-		const struct damon_sysfs_report_filter_type_name *type_name;
+	for (; i < ARRAY_SIZE(damon_sysfs_sample_filter_type_names); i++) {
+		const struct damon_sysfs_sample_filter_type_name *type_name;
 
-		type_name = &damon_sysfs_report_filter_type_names[i];
+		type_name = &damon_sysfs_sample_filter_type_names[i];
 		if (sysfs_streq(buf, type_name->name)) {
 			filter->type = type_name->type;
 			ret = count;
@@ -825,8 +825,8 @@ static ssize_t type_store(struct kobject *kobj,
 static ssize_t matching_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 
 	return sysfs_emit(buf, "%c\n", filter->matching ? 'Y' : 'N');
 }
@@ -834,8 +834,8 @@ static ssize_t matching_show(struct kobject *kobj,
 static ssize_t matching_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 	bool matching;
 	int err = kstrtobool(buf, &matching);
 
@@ -849,8 +849,8 @@ static ssize_t matching_store(struct kobject *kobj,
 static ssize_t allow_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 
 	return sysfs_emit(buf, "%c\n", filter->allow ? 'Y' : 'N');
 }
@@ -858,8 +858,8 @@ static ssize_t allow_show(struct kobject *kobj,
 static ssize_t allow_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 	bool allow;
 	int err = kstrtobool(buf, &allow);
 
@@ -873,8 +873,8 @@ static ssize_t allow_store(struct kobject *kobj,
 static ssize_t cpumask_show(struct kobject *kobj, struct kobj_attribute *attr,
 		char *buf)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 
 	return sysfs_emit(buf, "%*pbl\n", cpumask_pr_args(&filter->cpumask));
 }
@@ -882,8 +882,8 @@ static ssize_t cpumask_show(struct kobject *kobj, struct kobj_attribute *attr,
 static ssize_t cpumask_store(struct kobject *kobj, struct kobj_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 	cpumask_t cpumask;
 	int err = cpulist_parse(buf, &cpumask);
 
@@ -896,20 +896,20 @@ static ssize_t cpumask_store(struct kobject *kobj, struct kobj_attribute *attr,
 static ssize_t tid_arr_show(struct kobject *kobj, struct kobj_attribute *attr,
 		char *buf)
 {
-	struct damon_sysfs_report_filter *report_filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *sample_filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 	char *str;
 	int nr_tids, *tid_arr;
 	int i, ret;
 
-	if (!report_filter->tid_arr)
+	if (!sample_filter->tid_arr)
 		return sysfs_emit(buf, "\n");
 
 	str = kcalloc(2048, sizeof(*str), GFP_KERNEL);
 	if (!str)
 		return -ENOMEM;
-	nr_tids = report_filter->tid_arr[0];
-	tid_arr = &report_filter->tid_arr[1];
+	nr_tids = sample_filter->tid_arr[0];
+	tid_arr = &sample_filter->tid_arr[1];
 	for (i = 0; i < nr_tids; i++) {
 		snprintf(&str[strlen(str)], 2048 - strlen(str), "%d",
 				tid_arr[i]);
@@ -924,75 +924,75 @@ static ssize_t tid_arr_show(struct kobject *kobj, struct kobj_attribute *attr,
 static ssize_t tid_arr_store(struct kobject *kobj, struct kobj_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct damon_sysfs_report_filter *report_filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *sample_filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 	int err;
 
-	err = parse_int_array(buf, count, &report_filter->tid_arr);
+	err = parse_int_array(buf, count, &sample_filter->tid_arr);
 	if (err)
 		return err;
 	return count;
 }
 
-static void damon_sysfs_report_filter_release(struct kobject *kobj)
+static void damon_sysfs_sample_filter_release(struct kobject *kobj)
 {
-	struct damon_sysfs_report_filter *filter = container_of(kobj,
-			struct damon_sysfs_report_filter, kobj);
+	struct damon_sysfs_sample_filter *filter = container_of(kobj,
+			struct damon_sysfs_sample_filter, kobj);
 
 	kfree(filter);
 }
 
-static struct kobj_attribute damon_sysfs_report_filter_type_attr =
+static struct kobj_attribute damon_sysfs_sample_filter_type_attr =
 		__ATTR_RW_MODE(type, 0600);
 
-static struct kobj_attribute damon_sysfs_report_filter_matching_attr =
+static struct kobj_attribute damon_sysfs_sample_filter_matching_attr =
 		__ATTR_RW_MODE(matching, 0600);
 
-static struct kobj_attribute damon_sysfs_report_filter_allow_attr =
+static struct kobj_attribute damon_sysfs_sample_filter_allow_attr =
 		__ATTR_RW_MODE(allow, 0600);
 
-static struct kobj_attribute damon_sysfs_report_filter_cpumask_attr =
+static struct kobj_attribute damon_sysfs_sample_filter_cpumask_attr =
 		__ATTR_RW_MODE(cpumask, 0600);
 
-static struct kobj_attribute damon_sysfs_report_filter_tid_arr_attr =
+static struct kobj_attribute damon_sysfs_sample_filter_tid_arr_attr =
 		__ATTR_RW_MODE(tid_arr, 0600);
 
-static struct attribute *damon_sysfs_report_filter_attrs[] = {
-	&damon_sysfs_report_filter_type_attr.attr,
-	&damon_sysfs_report_filter_matching_attr.attr,
-	&damon_sysfs_report_filter_allow_attr.attr,
-	&damon_sysfs_report_filter_cpumask_attr.attr,
-	&damon_sysfs_report_filter_tid_arr_attr.attr,
+static struct attribute *damon_sysfs_sample_filter_attrs[] = {
+	&damon_sysfs_sample_filter_type_attr.attr,
+	&damon_sysfs_sample_filter_matching_attr.attr,
+	&damon_sysfs_sample_filter_allow_attr.attr,
+	&damon_sysfs_sample_filter_cpumask_attr.attr,
+	&damon_sysfs_sample_filter_tid_arr_attr.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(damon_sysfs_report_filter);
+ATTRIBUTE_GROUPS(damon_sysfs_sample_filter);
 
-static const struct kobj_type damon_sysfs_report_filter_ktype = {
-	.release = damon_sysfs_report_filter_release,
+static const struct kobj_type damon_sysfs_sample_filter_ktype = {
+	.release = damon_sysfs_sample_filter_release,
 	.sysfs_ops = &kobj_sysfs_ops,
-	.default_groups = damon_sysfs_report_filter_groups,
+	.default_groups = damon_sysfs_sample_filter_groups,
 };
 
 /*
  * access check report filters directory
  */
 
-struct damon_sysfs_report_filters {
+struct damon_sysfs_sample_filters {
 	struct kobject kobj;
-	struct damon_sysfs_report_filter **filters_arr;
+	struct damon_sysfs_sample_filter **filters_arr;
 	int nr;
 };
 
-static struct damon_sysfs_report_filters *
-damon_sysfs_report_filters_alloc(void)
+static struct damon_sysfs_sample_filters *
+damon_sysfs_sample_filters_alloc(void)
 {
-	return kzalloc(sizeof(struct damon_sysfs_report_filters), GFP_KERNEL);
+	return kzalloc(sizeof(struct damon_sysfs_sample_filters), GFP_KERNEL);
 }
 
-static void damon_sysfs_report_filters_rm_dirs(
-		struct damon_sysfs_report_filters *filters)
+static void damon_sysfs_sample_filters_rm_dirs(
+		struct damon_sysfs_sample_filters *filters)
 {
-	struct damon_sysfs_report_filter **filters_arr = filters->filters_arr;
+	struct damon_sysfs_sample_filter **filters_arr = filters->filters_arr;
 	int i;
 
 	for (i = 0; i < filters->nr; i++)
@@ -1002,13 +1002,13 @@ static void damon_sysfs_report_filters_rm_dirs(
 	filters->filters_arr = NULL;
 }
 
-static int damon_sysfs_report_filters_add_dirs(
-		struct damon_sysfs_report_filters *filters, int nr_filters)
+static int damon_sysfs_sample_filters_add_dirs(
+		struct damon_sysfs_sample_filters *filters, int nr_filters)
 {
-	struct damon_sysfs_report_filter **filters_arr, *filter;
+	struct damon_sysfs_sample_filter **filters_arr, *filter;
 	int err, i;
 
-	damon_sysfs_report_filters_rm_dirs(filters);
+	damon_sysfs_sample_filters_rm_dirs(filters);
 	if (!nr_filters)
 		return 0;
 
@@ -1019,18 +1019,18 @@ static int damon_sysfs_report_filters_add_dirs(
 	filters->filters_arr = filters_arr;
 
 	for (i = 0; i < nr_filters; i++) {
-		filter = damon_sysfs_report_filter_alloc();
+		filter = damon_sysfs_sample_filter_alloc();
 		if (!filter) {
-			damon_sysfs_report_filters_rm_dirs(filters);
+			damon_sysfs_sample_filters_rm_dirs(filters);
 			return -ENOMEM;
 		}
 
 		err = kobject_init_and_add(&filter->kobj,
-				&damon_sysfs_report_filter_ktype,
+				&damon_sysfs_sample_filter_ktype,
 				&filters->kobj, "%d", i);
 		if (err) {
 			kobject_put(&filter->kobj);
-			damon_sysfs_report_filters_rm_dirs(filters);
+			damon_sysfs_sample_filters_rm_dirs(filters);
 			return err;
 		}
 
@@ -1043,8 +1043,8 @@ static int damon_sysfs_report_filters_add_dirs(
 static ssize_t nr_filters_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
-	struct damon_sysfs_report_filters *filters = container_of(kobj,
-			struct damon_sysfs_report_filters, kobj);
+	struct damon_sysfs_sample_filters *filters = container_of(kobj,
+			struct damon_sysfs_sample_filters, kobj);
 
 	return sysfs_emit(buf, "%d\n", filters->nr);
 }
@@ -1052,7 +1052,7 @@ static ssize_t nr_filters_show(struct kobject *kobj,
 static ssize_t nr_filters_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
-	struct damon_sysfs_report_filters *filters;
+	struct damon_sysfs_sample_filters *filters;
 	int nr, err = kstrtoint(buf, 0, &nr);
 
 	if (err)
@@ -1060,11 +1060,11 @@ static ssize_t nr_filters_store(struct kobject *kobj,
 	if (nr < 0)
 		return -EINVAL;
 
-	filters = container_of(kobj, struct damon_sysfs_report_filters, kobj);
+	filters = container_of(kobj, struct damon_sysfs_sample_filters, kobj);
 
 	if (!mutex_trylock(&damon_sysfs_lock))
 		return -EBUSY;
-	err = damon_sysfs_report_filters_add_dirs(filters, nr);
+	err = damon_sysfs_sample_filters_add_dirs(filters, nr);
 	mutex_unlock(&damon_sysfs_lock);
 	if (err)
 		return err;
@@ -1072,24 +1072,24 @@ static ssize_t nr_filters_store(struct kobject *kobj,
 	return count;
 }
 
-static void damon_sysfs_report_filters_release(struct kobject *kobj)
+static void damon_sysfs_sample_filters_release(struct kobject *kobj)
 {
-	kfree(container_of(kobj, struct damon_sysfs_report_filters, kobj));
+	kfree(container_of(kobj, struct damon_sysfs_sample_filters, kobj));
 }
 
-static struct kobj_attribute damon_sysfs_report_filters_nr_attr =
+static struct kobj_attribute damon_sysfs_sample_filters_nr_attr =
 		__ATTR_RW_MODE(nr_filters, 0600);
 
-static struct attribute *damon_sysfs_report_filters_attrs[] = {
-	&damon_sysfs_report_filters_nr_attr.attr,
+static struct attribute *damon_sysfs_sample_filters_attrs[] = {
+	&damon_sysfs_sample_filters_nr_attr.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(damon_sysfs_report_filters);
+ATTRIBUTE_GROUPS(damon_sysfs_sample_filters);
 
-static const struct kobj_type damon_sysfs_report_filters_ktype = {
-	.release = damon_sysfs_report_filters_release,
+static const struct kobj_type damon_sysfs_sample_filters_ktype = {
+	.release = damon_sysfs_sample_filters_release,
 	.sysfs_ops = &kobj_sysfs_ops,
-	.default_groups = damon_sysfs_report_filters_groups,
+	.default_groups = damon_sysfs_sample_filters_groups,
 };
 
 /*
@@ -1197,7 +1197,7 @@ static const struct kobj_type damon_sysfs_primitives_ktype = {
 struct damon_sysfs_sample {
 	struct kobject kobj;
 	struct damon_sysfs_primitives *primitives;
-	struct damon_sysfs_report_filters *filters;
+	struct damon_sysfs_sample_filters *filters;
 };
 
 static struct damon_sysfs_sample *damon_sysfs_sample_alloc(void)
@@ -1215,7 +1215,7 @@ static int damon_sysfs_sample_add_dirs(
 		struct damon_sysfs_sample *sample)
 {
 	struct damon_sysfs_primitives *primitives;
-	struct damon_sysfs_report_filters *filters;
+	struct damon_sysfs_sample_filters *filters;
 	int err;
 
 	primitives = damon_sysfs_primitives_alloc(true, false);
@@ -1228,12 +1228,12 @@ static int damon_sysfs_sample_add_dirs(
 		goto put_primitives_out;
 	sample->primitives = primitives;
 
-	filters = damon_sysfs_report_filters_alloc();
+	filters = damon_sysfs_sample_filters_alloc();
 	if (!filters)
 		return -ENOMEM;
 	err = kobject_init_and_add(&filters->kobj,
-			&damon_sysfs_report_filters_ktype, &sample->kobj,
-			"report_filters");
+			&damon_sysfs_sample_filters_ktype, &sample->kobj,
+			"sample_filters");
 	if (err)
 		goto put_filters_out;
 	sample->filters = filters;
@@ -1253,7 +1253,7 @@ static void damon_sysfs_sample_rm_dirs(
 	if (sample->primitives)
 		kobject_put(&sample->primitives->kobj);
 	if (sample->filters) {
-		damon_sysfs_report_filters_rm_dirs(sample->filters);
+		damon_sysfs_sample_filters_rm_dirs(sample->filters);
 		kobject_put(&sample->filters->kobj);
 	}
 }
@@ -2199,7 +2199,7 @@ static inline bool damon_sysfs_kdamond_running(
 		damon_is_running(kdamond->damon_ctx);
 }
 
-static int damon_sysfs_set_threads_filter(struct damon_report_filter *filter,
+static int damon_sysfs_set_threads_filter(struct damon_sample_filter *filter,
 		int *sysfs_tid_arr)
 {
 	int nr_tids, i;
@@ -2218,18 +2218,18 @@ static int damon_sysfs_set_threads_filter(struct damon_report_filter *filter,
 	return 0;
 }
 
-static int damon_sysfs_set_report_filters(
+static int damon_sysfs_set_sample_filters(
 		struct damon_sample_control *control,
-		struct damon_sysfs_report_filters *sysfs_filters)
+		struct damon_sysfs_sample_filters *sysfs_filters)
 {
 	int i, err;
 
 	for (i = 0; i < sysfs_filters->nr; i++) {
-		struct damon_sysfs_report_filter *sysfs_filter =
+		struct damon_sysfs_sample_filter *sysfs_filter =
 			sysfs_filters->filters_arr[i];
-		struct damon_report_filter *filter;
+		struct damon_sample_filter *filter;
 
-		filter = damon_new_report_filter(
+		filter = damon_new_sample_filter(
 				sysfs_filter->type, sysfs_filter->matching,
 				sysfs_filter->allow);
 		if (!filter)
@@ -2242,12 +2242,12 @@ static int damon_sysfs_set_report_filters(
 			err = damon_sysfs_set_threads_filter(filter,
 					sysfs_filter->tid_arr);
 			if (err)
-				damon_free_report_filter(filter);
+				damon_free_sample_filter(filter);
 			break;
 		default:
 			break;
 		}
-		damon_add_report_filter(control, filter);
+		damon_add_sample_filter(control, filter);
 	}
 	return 0;
 }
@@ -2262,7 +2262,7 @@ static int damon_sysfs_set_sample_control(
 	control->primitives_enabled.page_faults =
 		sysfs_sample->primitives->page_faults;
 
-	return damon_sysfs_set_report_filters(control,
+	return damon_sysfs_set_sample_filters(control,
 			sysfs_sample->filters);
 }
 
-- 
2.47.3

