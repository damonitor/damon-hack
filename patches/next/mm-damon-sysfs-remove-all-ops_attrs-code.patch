From: SeongJae Park <sj@kernel.org>
Date: Sun, 30 Nov 2025 13:29:30 -0800
Subject: [PATCH] mm/damon/sysfs: remove all ops_attrs code

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/sysfs.c | 221 -----------------------------------------------
 1 file changed, 221 deletions(-)

diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index e7645a9bbd52..413e8f39d8a2 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -1388,177 +1388,6 @@ static const struct kobj_type damon_sysfs_attrs_ktype = {
 	.default_groups = damon_sysfs_attrs_groups,
 };
 
-/*
- * operation attrs directory
- */
-
-struct damon_sysfs_ops_attrs {
-	struct kobject kobj;
-	bool use_reports;
-	bool write_only;
-	cpumask_t cpus;
-	int *tids;	/* first entry is the size */
-};
-
-static struct damon_sysfs_ops_attrs *damon_sysfs_ops_attrs_alloc(void)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = kmalloc(sizeof(*ops_attrs),
-			GFP_KERNEL);
-
-	if (!ops_attrs)
-		return NULL;
-
-	ops_attrs->kobj = (struct kobject){};
-	ops_attrs->use_reports = false;
-	ops_attrs->write_only = false;
-	cpumask_setall(&ops_attrs->cpus);
-	ops_attrs->tids = NULL;
-	return ops_attrs;
-}
-
-static ssize_t use_reports_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-
-	return sysfs_emit(buf, "%c\n", ops_attrs->use_reports ? 'Y' : 'N');
-}
-
-static ssize_t use_reports_store(struct kobject *kobj,
-		struct kobj_attribute *attr, const char *buf, size_t count)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-	bool use;
-	int err = kstrtobool(buf, &use);
-
-	if (err)
-		return err;
-	ops_attrs->use_reports = use;
-	return count;
-}
-
-static ssize_t write_only_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-
-	return sysfs_emit(buf, "%c\n", ops_attrs->write_only ? 'Y' : 'N');
-}
-
-static ssize_t write_only_store(struct kobject *kobj,
-		struct kobj_attribute *attr, const char *buf, size_t count)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-	bool write_only;
-	int err = kstrtobool(buf, &write_only);
-
-	if (err)
-		return err;
-	ops_attrs->write_only = write_only;
-	return count;
-}
-
-static ssize_t cpus_show(struct kobject *kobj, struct kobj_attribute *attr,
-		char *buf)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-
-	return sysfs_emit(buf, "%*pbl\n", cpumask_pr_args(&ops_attrs->cpus));
-}
-
-static ssize_t cpus_store(struct kobject *kobj, struct kobj_attribute *attr,
-		const char *buf, size_t count)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-	cpumask_t cpus;
-	int err = cpulist_parse(buf, &cpus);
-
-	if (err)
-		return err;
-	ops_attrs->cpus = cpus;
-	return count;
-}
-
-static ssize_t tids_show(struct kobject *kobj, struct kobj_attribute *attr,
-		char *buf)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-	char *str;
-	int i, ret;
-
-	if (!ops_attrs->tids)
-		return sysfs_emit(buf, "\n");
-
-	str = kcalloc(2048, sizeof(*str), GFP_KERNEL);
-	if (!str)
-		return -ENOMEM;
-	for (i = 0; i < ops_attrs->tids[0]; i++) {
-		snprintf(&str[strlen(str)], 2048 - strlen(str),
-				"%d", ops_attrs->tids[i + 1]);
-		if (i < ops_attrs->tids[0] - 1)
-			snprintf(&str[strlen(str)], 2048 - strlen(str), ",");
-	}
-	ret = sysfs_emit(buf, "%s\n", str);
-	kfree(str);
-	return ret;
-}
-
-static ssize_t tids_store(struct kobject *kobj, struct kobj_attribute *attr,
-		const char *buf, size_t count)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-	int err;
-
-	err = parse_int_array(buf, count, &ops_attrs->tids);
-	if (err)
-		return err;
-	return count;
-}
-
-static void damon_sysfs_ops_attrs_release(struct kobject *kobj)
-{
-	struct damon_sysfs_ops_attrs *ops_attrs = container_of(kobj,
-			struct damon_sysfs_ops_attrs, kobj);
-
-	kfree(ops_attrs->tids);
-	kfree(container_of(kobj, struct damon_sysfs_ops_attrs, kobj));
-}
-
-static struct kobj_attribute damon_sysfs_ops_attrs_use_reports_attr =
-		__ATTR_RW_MODE(use_reports, 0600);
-
-static struct kobj_attribute damon_sysfs_ops_attrs_write_only_attr =
-		__ATTR_RW_MODE(write_only, 0600);
-
-static struct kobj_attribute damon_sysfs_ops_attrs_cpus_attr =
-		__ATTR_RW_MODE(cpus, 0600);
-
-static struct kobj_attribute damon_sysfs_ops_attrs_tids_attr =
-		__ATTR_RW_MODE(tids, 0600);
-
-static struct attribute *damon_sysfs_ops_attrs_attrs[] = {
-	&damon_sysfs_ops_attrs_use_reports_attr.attr,
-	&damon_sysfs_ops_attrs_write_only_attr.attr,
-	&damon_sysfs_ops_attrs_cpus_attr.attr,
-	&damon_sysfs_ops_attrs_tids_attr.attr,
-	NULL,
-};
-ATTRIBUTE_GROUPS(damon_sysfs_ops_attrs);
-
-static const struct kobj_type damon_sysfs_ops_attrs_ktype = {
-	.release = damon_sysfs_ops_attrs_release,
-	.sysfs_ops = &kobj_sysfs_ops,
-	.default_groups = damon_sysfs_ops_attrs_groups,
-};
-
 /*
  * context directory
  */
@@ -1586,7 +1415,6 @@ static const struct damon_sysfs_ops_name damon_sysfs_ops_names[] = {
 struct damon_sysfs_context {
 	struct kobject kobj;
 	enum damon_ops_id ops_id;
-	struct damon_sysfs_ops_attrs *ops_attrs;
 	unsigned long addr_unit;
 	struct damon_sysfs_attrs *attrs;
 	struct damon_sysfs_targets *targets;
@@ -1607,23 +1435,6 @@ static struct damon_sysfs_context *damon_sysfs_context_alloc(
 	return context;
 }
 
-static int damon_sysfs_context_set_ops_attrs(
-		struct damon_sysfs_context *context)
-{
-	struct damon_sysfs_ops_attrs *attrs = damon_sysfs_ops_attrs_alloc();
-	int err;
-
-	if (!attrs)
-		return -ENOMEM;
-	err = kobject_init_and_add(&attrs->kobj, &damon_sysfs_ops_attrs_ktype,
-			&context->kobj, "operations_attrs");
-	if (err)
-		kobject_put(&attrs->kobj);
-	else
-		context->ops_attrs = attrs;
-	return err;
-}
-
 static int damon_sysfs_context_set_attrs(struct damon_sysfs_context *context)
 {
 	struct damon_sysfs_attrs *attrs = damon_sysfs_attrs_alloc();
@@ -2264,30 +2075,6 @@ static int damon_sysfs_set_sample_control(
 			sysfs_sample->filters);
 }
 
-static int damon_sysfs_set_ops_attrs_tids(
-		struct damon_operations_attrs *ops_attrs,
-		int *sysfs_tids)
-{
-	int i;
-
-	if (!sysfs_tids)
-		return 0;
-
-	/* todo: keep old tids after failure? */
-	if (ops_attrs->nr_tids) {
-		kfree(ops_attrs->tids);
-		ops_attrs->nr_tids = 0;
-	}
-	ops_attrs->tids = kmalloc_array(sysfs_tids[0],
-			sizeof(*ops_attrs->tids), GFP_KERNEL);
-	if (!ops_attrs->tids)
-		return -ENOMEM;
-	for (i = 0; i < sysfs_tids[0]; i++)
-		ops_attrs->tids[i] = sysfs_tids[i + 1];
-	ops_attrs->nr_tids = sysfs_tids[0];
-	return 0;
-}
-
 static int damon_sysfs_apply_inputs(struct damon_ctx *ctx,
 		struct damon_sysfs_context *sys_ctx)
 {
@@ -2296,14 +2083,6 @@ static int damon_sysfs_apply_inputs(struct damon_ctx *ctx,
 	err = damon_select_ops(ctx, sys_ctx->ops_id);
 	if (err)
 		return err;
-	ctx->ops_attrs.use_reports = sys_ctx->ops_attrs->use_reports;
-	ctx->ops_attrs.write_only = sys_ctx->ops_attrs->write_only;
-	ctx->ops_attrs.cpus = sys_ctx->ops_attrs->cpus;
-	err = damon_sysfs_set_ops_attrs_tids(
-			&ctx->ops_attrs, sys_ctx->ops_attrs->tids);
-	if (err)
-		return err;
-
 	ctx->addr_unit = sys_ctx->addr_unit;
 	/* addr_unit is respected by only DAMON_OPS_PADDR */
 	if (sys_ctx->ops_id == DAMON_OPS_PADDR)
-- 
2.47.3

