From: SeongJae Park <sj@kernel.org>
Date: Wed, 29 Jan 2025 10:40:36 -0800
Subject: [PATCH] mm/damon: use intervals tuning target as samples ratio, not
 absolute number

Since the number of regions can change, absolute number samples goal
makes no much sense.  Use ratio in bp.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h | 26 +++++++++++++-------------
 mm/damon/core.c       | 13 +++++++++----
 mm/damon/sysfs.c      | 22 +++++++++++-----------
 3 files changed, 33 insertions(+), 28 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index d563db7667a8..bfecf6079dc1 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -634,26 +634,26 @@ struct damon_call_control {
 /**
  * struct damon_intervals_goal - Monitoring intervals auto-tuning goal.
  *
- * @samples:		Number of positive access check samples to achieve.
+ * @samples_bp:		Positive access check samples ratio to achieve.
  * @aggrs:		Number of aggregations to acheive @samples within.
  * @min_sample_us:	Minimum resulting sampling interval in microseconds.
  * @max_sample_us:	Maximum resulting sampling interval in microseconds.
  *
  * DAMON automatically tunes &damon_attrs->sample_interval and
- * &damon_attrs->aggr_interval aiming the number of access check samples that
- * shown positive result (was accessed) within @aggrs aggregations be same to
- * @samples.  The logic increases &damon_attrs->aggr_interval and
- * &damon_attrs->sampling_interval in same ratio if the current positive access
- * samples ratio is lower than the target for each @aggrs aggregations, and
- * vice versa.
- *
- * If @aggrs is zero, the tuning is disabled.  If any input makes no sense
- * (e.g., @min_sample_us is samller than @max_sample_us, or
- * &damon_attrs->sample_interval is out of @min_sample_us-@max_sample_us
- * range), damon_commit_ctx() returns an error.
+ * &damon_attrs->aggr_interval aiming the ratio in bp (1/10,000) of access
+ * check samples that shown positive result (was accessed) to total samples
+ * within @aggrs aggregations be same to @samples_bp.  The logic increases
+ * &damon_attrs->aggr_interval and &damon_attrs->sampling_interval in same
+ * ratio if the current positive access samples ratio is lower than the target
+ * for each @aggrs aggregations, and vice versa.
+ *
+ * If @aggrs is zero, the tuning is disabled and hence this struct is ignored.
+ * If it is not zero and any input makes no sense (e.g., @min_sample_us is
+ * samller than @max_sample_us, or &damon_attrs->sample_interval is out of
+ * @min_sample_us-@max_sample_us range), damon_commit_ctx() returns an error.
  */
 struct damon_intervals_goal {
-	unsigned long samples;
+	unsigned long samples_bp;
 	unsigned long aggrs;
 	unsigned long min_sample_us;
 	unsigned long max_sample_us;
diff --git a/mm/damon/core.c b/mm/damon/core.c
index d24a5b978186..dab9444fdd01 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -1308,20 +1308,25 @@ static unsigned long damon_get_intervals_adaptation_bp(struct damon_ctx *c)
 {
 	struct damon_target *t;
 	struct damon_region *r;
-	unsigned long access_samples = 0, score_bp;
+	unsigned long nr_regions = 0, access_samples = 0;
+	struct damon_intervals_goal *goal = &c->attrs.intervals_goal;
+	unsigned long max_samples, target_samples, score_bp;
 	unsigned long adaptation_bp;
 
 	damon_for_each_target(t, c) {
+		nr_regions = damon_nr_regions(t);
 		damon_for_each_region(r, t)
 			access_samples += r->nr_accesses;
 	}
-	score_bp = access_samples * 10000 / c->attrs.intervals_goal.samples;
+	max_samples = nr_regions * c->attrs.aggr_samples;
+	target_samples = max_samples * goal->samples_bp / 10000;
+	score_bp = access_samples * 10000 / target_samples;
 	adaptation_bp = damon_feed_loop_next_input(100000000, score_bp) /
 		10000;
 
 	pr_info("access_samples %lu/%lu, score_bp %lu, adaptation bp %lu\n",
-			access_samples, c->attrs.intervals_goal.samples,
-			score_bp, adaptation_bp);
+			access_samples, target_samples, score_bp,
+			adaptation_bp);
 	return adaptation_bp;
 }
 
diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index 00b014ecfd39..b5035f19914a 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -414,14 +414,14 @@ static const struct kobj_type damon_sysfs_targets_ktype = {
 
 struct damon_sysfs_intervals_goal {
 	struct kobject kobj;
-	unsigned long samples;
+	unsigned long samples_bp;
 	unsigned long aggrs;
 	unsigned long min_sample_us;
 	unsigned long max_sample_us;
 };
 
 static struct damon_sysfs_intervals_goal *damon_sysfs_intervals_goal_alloc(
-		unsigned long samples, unsigned long aggrs,
+		unsigned long samples_bp, unsigned long aggrs,
 		unsigned long min_sample_us, unsigned long max_sample_us)
 {
 	struct damon_sysfs_intervals_goal *goal = kmalloc(sizeof(*goal),
@@ -431,23 +431,23 @@ static struct damon_sysfs_intervals_goal *damon_sysfs_intervals_goal_alloc(
 		return NULL;
 
 	goal->kobj = (struct kobject){};
-	goal->samples = samples;
+	goal->samples_bp = samples_bp;
 	goal->aggrs = aggrs;
 	goal->min_sample_us = min_sample_us;
 	goal->max_sample_us = max_sample_us;
 	return goal;
 }
 
-static ssize_t samples_show(struct kobject *kobj,
+static ssize_t samples_bp_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
 	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
 			struct damon_sysfs_intervals_goal, kobj);
 
-	return sysfs_emit(buf, "%lu\n", goal->samples);
+	return sysfs_emit(buf, "%lu\n", goal->samples_bp);
 }
 
-static ssize_t samples_store(struct kobject *kobj,
+static ssize_t samples_bp_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
 	struct damon_sysfs_intervals_goal *goal = container_of(kobj,
@@ -458,7 +458,7 @@ static ssize_t samples_store(struct kobject *kobj,
 	if (err)
 		return err;
 
-	goal->samples = nr;
+	goal->samples_bp = nr;
 	return count;
 }
 
@@ -539,8 +539,8 @@ static void damon_sysfs_intervals_goal_release(struct kobject *kobj)
 	kfree(container_of(kobj, struct damon_sysfs_intervals_goal, kobj));
 }
 
-static struct kobj_attribute damon_sysfs_intervals_goal_samples_attr =
-		__ATTR_RW_MODE(samples, 0600);
+static struct kobj_attribute damon_sysfs_intervals_goal_samples_bp_attr =
+		__ATTR_RW_MODE(samples_bp, 0600);
 
 static struct kobj_attribute damon_sysfs_intervals_goal_aggrs_attr =
 		__ATTR_RW_MODE(aggrs, 0600);
@@ -552,7 +552,7 @@ static struct kobj_attribute damon_sysfs_intervals_goal_max_sample_us_attr =
 		__ATTR_RW_MODE(max_sample_us, 0600);
 
 static struct attribute *damon_sysfs_intervals_goal_attrs[] = {
-	&damon_sysfs_intervals_goal_samples_attr.attr,
+	&damon_sysfs_intervals_goal_samples_bp_attr.attr,
 	&damon_sysfs_intervals_goal_aggrs_attr.attr,
 	&damon_sysfs_intervals_goal_min_sample_us_attr.attr,
 	&damon_sysfs_intervals_goal_max_sample_us_attr.attr,
@@ -1287,7 +1287,7 @@ static int damon_sysfs_set_attrs(struct damon_ctx *ctx,
 		.sample_interval = sys_intervals->sample_us,
 		.aggr_interval = sys_intervals->aggr_us,
 		.intervals_goal = {
-			.samples = sys_goal->samples,
+			.samples_bp = sys_goal->samples_bp,
 			.aggrs = sys_goal->aggrs,
 			.min_sample_us = sys_goal->min_sample_us,
 			.max_sample_us = sys_goal->max_sample_us},
-- 
2.39.5

