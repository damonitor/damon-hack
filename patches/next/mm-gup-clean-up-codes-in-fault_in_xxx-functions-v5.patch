From: Baoquan He <bhe@redhat.com>
Date: Sun, 13 Apr 2025 10:04:47 +0800
Subject: [PATCH] mm-gup-clean-up-codes-in-fault_in_xxx-functions-v5

address minor concerns from David

Link: https://lkml.kernel.org/r/Z/sbv3EmLXWgEE7+@MiWiFi-R3L-srv
Signed-off-by: Baoquan He <bhe@redhat.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
---
 mm/gup.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/mm/gup.c b/mm/gup.c
index a76bd7e90a71..f32168339390 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -2115,18 +2115,16 @@ size_t fault_in_writeable(char __user *uaddr, size_t size)
 {
 	const unsigned long start = (unsigned long)uaddr;
 	const unsigned long end = start + size;
-	unsigned long cur = start;
+	unsigned long cur;
 
 	if (unlikely(size == 0))
 		return 0;
-
 	if (!user_write_access_begin(uaddr, size))
 		return size;
 
 	/* Stop once we overflow to 0. */
-	for (; cur && cur < end; cur = PAGE_ALIGN_DOWN(cur + PAGE_SIZE))
+	for (cur = start; cur && cur < end; cur = PAGE_ALIGN_DOWN(cur + PAGE_SIZE))
 		unsafe_put_user(0, (char __user *)cur, out);
-
 out:
 	user_write_access_end();
 	if (size > cur - start)
@@ -2186,7 +2184,7 @@ size_t fault_in_safe_writeable(const char __user *uaddr, size_t size)
 {
 	const unsigned long start = (unsigned long)uaddr;
 	const unsigned long end = start + size;
-	unsigned long cur = start;
+	unsigned long cur;
 	struct mm_struct *mm = current->mm;
 	bool unlocked = false;
 
@@ -2195,7 +2193,7 @@ size_t fault_in_safe_writeable(const char __user *uaddr, size_t size)
 
 	mmap_read_lock(mm);
 	/* Stop once we overflow to 0. */
-	for (; cur && cur < end; cur = PAGE_ALIGN_DOWN(cur + PAGE_SIZE))
+	for (cur = start; cur && cur < end; cur = PAGE_ALIGN_DOWN(cur + PAGE_SIZE))
 		if (fixup_user_fault(mm, cur, FAULT_FLAG_WRITE, &unlocked))
 			break;
 	mmap_read_unlock(mm);
@@ -2218,15 +2216,16 @@ size_t fault_in_readable(const char __user *uaddr, size_t size)
 {
 	const unsigned long start = (unsigned long)uaddr;
 	const unsigned long end = start + size;
-	unsigned long cur = start;
+	unsigned long cur;
 	volatile char c;
 
 	if (unlikely(size == 0))
 		return 0;
 	if (!user_read_access_begin(uaddr, size))
 		return size;
+
 	/* Stop once we overflow to 0. */
-	for (; cur && cur < end; cur = PAGE_ALIGN_DOWN(cur + PAGE_SIZE))
+	for (cur = start; cur && cur < end; cur = PAGE_ALIGN_DOWN(cur + PAGE_SIZE))
 		unsafe_get_user(c, (const char __user *)cur, out);
 out:
 	user_read_access_end();
-- 
2.39.5

