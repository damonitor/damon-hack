From f555f7b7a2bb8d9ef0c3cc9ae26671b7fc5ad4d5 Mon Sep 17 00:00:00 2001
From: SeongJae Park <sj@kernel.org>
Date: Sat, 11 May 2024 11:15:40 -0700
Subject: [PATCH] patch 5: address comment

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h    |  2 +-
 mm/damon/paddr.c         | 37 +++++++++++++++----------------------
 mm/damon/sysfs-schemes.c |  3 ---
 3 files changed, 16 insertions(+), 26 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index 4e034580c14f..56714b6eb0d7 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -105,7 +105,7 @@ struct damon_target {
  * @DAMOS_NOHUGEPAGE:	Call ``madvise()`` for the region with MADV_NOHUGEPAGE.
  * @DAMOS_LRU_PRIO:	Prioritize the region on its LRU lists.
  * @DAMOS_LRU_DEPRIO:	Deprioritize the region on its LRU lists.
- * @DAMOS_MIGRATE_COLD: Migrate for the given cold region.
+ * @DAMOS_MIGRATE_COLD:	Migrate the regions prioritizing colder regions.
  * @DAMOS_STAT:		Do nothing but count the stat.
  * @NR_DAMOS_ACTIONS:	Total number of DAMOS actions
  *
diff --git a/mm/damon/paddr.c b/mm/damon/paddr.c
index a2d4825dcd85..30171f4b863b 100644
--- a/mm/damon/paddr.c
+++ b/mm/damon/paddr.c
@@ -248,13 +248,12 @@ enum migration_mode {
 	MIG_MIGRATE_COLD,
 };
 
-static unsigned int migrate_folio_list(struct list_head *migrate_folios,
-				       struct pglist_data *pgdat,
-				       int target_nid)
+static unsigned int __damon_pa_migrate_folio_list(
+		struct list_head *migrate_folios, struct pglist_data *pgdat,
+		int target_nid)
 {
 	unsigned int nr_succeeded;
 	nodemask_t allowed_mask = NODE_MASK_NONE;
-
 	struct migration_target_control mtc = {
 		/*
 		 * Allocate from 'node', or fail quickly and quietly.
@@ -283,7 +282,6 @@ static unsigned int migrate_folio_list(struct list_head *migrate_folios,
 
 static unsigned int damon_pa_migrate_folio_list(struct list_head *folio_list,
 						struct pglist_data *pgdat,
-						enum migration_mode mm,
 						int target_nid)
 {
 	unsigned int nr_migrated = 0;
@@ -291,8 +289,6 @@ static unsigned int damon_pa_migrate_folio_list(struct list_head *folio_list,
 	LIST_HEAD(ret_folios);
 	LIST_HEAD(migrate_folios);
 
-	cond_resched();
-
 	while (!list_empty(folio_list)) {
 		struct folio *folio;
 
@@ -304,25 +300,24 @@ static unsigned int damon_pa_migrate_folio_list(struct list_head *folio_list,
 		if (!folio_trylock(folio))
 			goto keep;
 
-		VM_BUG_ON_FOLIO(folio_test_active(folio), folio);
-
 		/* Relocate its contents to another node. */
 		list_add(&folio->lru, &migrate_folios);
 		folio_unlock(folio);
 		continue;
 keep:
 		list_add(&folio->lru, &ret_folios);
-		VM_BUG_ON_FOLIO(folio_test_lru(folio), folio);
 	}
 	/* 'folio_list' is always empty here */
 
 	/* Migrate folios selected for migration */
-	nr_migrated += migrate_folio_list(&migrate_folios, pgdat, target_nid);
-	/* Folios that could not be migrated are still in @migrate_folios */
-	if (!list_empty(&migrate_folios)) {
-		/* Folios which weren't migrated go back on @folio_list */
+	nr_migrated += __damon_pa_migrate_folio_list(
+			&migrate_folios, pgdat, target_nid);
+	/*
+	 * Folios that could not be migrated are still in @migrate_folios.  Add
+	 * those back on @folio_list
+	 */
+	if (!list_empty(&migrate_folios))
 		list_splice_init(&migrate_folios, folio_list);
-	}
 
 	try_to_unmap_flush();
 
@@ -338,11 +333,10 @@ static unsigned int damon_pa_migrate_folio_list(struct list_head *folio_list,
 }
 
 static unsigned long damon_pa_migrate_pages(struct list_head *folio_list,
-					    enum migration_mode mm,
 					    int target_nid)
 {
 	int nid;
-	unsigned int nr_migrated = 0;
+	unsigned long nr_migrated = 0;
 	LIST_HEAD(node_folio_list);
 	unsigned int noreclaim_flag;
 
@@ -356,19 +350,18 @@ static unsigned long damon_pa_migrate_pages(struct list_head *folio_list,
 		struct folio *folio = lru_to_folio(folio_list);
 
 		if (nid == folio_nid(folio)) {
-			folio_clear_active(folio);
 			list_move(&folio->lru, &node_folio_list);
 			continue;
 		}
 
 		nr_migrated += damon_pa_migrate_folio_list(&node_folio_list,
-							   NODE_DATA(nid), mm,
+							   NODE_DATA(nid),
 							   target_nid);
 		nid = folio_nid(lru_to_folio(folio_list));
 	} while (!list_empty(folio_list));
 
 	nr_migrated += damon_pa_migrate_folio_list(&node_folio_list,
-						   NODE_DATA(nid), mm,
+						   NODE_DATA(nid),
 						   target_nid);
 
 	memalloc_noreclaim_restore(noreclaim_flag);
@@ -412,8 +405,8 @@ static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s,
 		if (!folio_isolate_lru(folio))
 			goto put_folio;
 		/*
-		 * Since unevictable folios can be demoted or promoted,
-		 * unevictable test is needed only for pageout.
+		 * Since unevictable folios can be migrated, unevictable test
+		 * is needed only for pageout.
 		 */
 		if (mm == MIG_PAGEOUT && folio_test_unevictable(folio))
 			folio_putback_lru(folio);
diff --git a/mm/damon/sysfs-schemes.c b/mm/damon/sysfs-schemes.c
index d9578535c198..880015d5b5ea 100644
--- a/mm/damon/sysfs-schemes.c
+++ b/mm/damon/sysfs-schemes.c
@@ -1712,9 +1712,6 @@ static ssize_t target_nid_store(struct kobject *kobj,
 			struct damon_sysfs_scheme, kobj);
 	int err = 0;
 
-        if (scheme->action != DAMOS_MIGRATE_COLD)
-                return -EINVAL;
-
 	/* TODO: error handling for target_nid range. */
 	err = kstrtoint(buf, 0, &scheme->target_nid);
 
-- 
2.39.2

