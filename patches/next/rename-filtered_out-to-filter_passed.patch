From: SeongJae Park <sj@kernel.org>
Date: Mon, 16 Dec 2024 16:33:30 -0800
Subject: [PATCH] rename filtered_out to filter_passed

Accounting passed bytes may feel more natural.  Also, make the name of
per-scheme stat more explicitly say it is for ops-handled fitlers
(sz_ops_filter_passed) since it is unclear what filters it is saying
about.  In case of per-region, only ops-handled filters can be applied,
so sz_filter_passed is enough.

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h    | 11 ++++----
 mm/damon/core.c          |  8 +++---
 mm/damon/paddr.c         | 60 +++++++++++++++++++++-------------------
 mm/damon/sysfs-common.h  |  2 +-
 mm/damon/sysfs-schemes.c | 31 +++++++++++----------
 mm/damon/sysfs.c         |  5 ++--
 mm/damon/vaddr.c         |  2 +-
 7 files changed, 61 insertions(+), 58 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index aba89b252ebe..115086ec2e4e 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -301,9 +301,8 @@ struct damos_watermarks {
  * @sz_tried:	Total size of regions that the scheme is tried to be applied.
  * @nr_applied:	Total number of regions that the scheme is applied.
  * @sz_applied:	Total size of regions that the scheme is applied.
- * @sz_filtered_out:
- * 		Total size of regions that the scheme is not applied due to
- * 		DAMOS filters.
+ * @sz_ops_filter_passed:
+ * 		Total bytes that passed ops layer-handled DAMOS filters.
  * @qt_exceeds: Total number of times the quota of the scheme has exceeded.
  *
  * "Tried an action to a region" in this context means the DAMOS core logic
@@ -328,7 +327,7 @@ struct damos_stat {
 	unsigned long sz_tried;
 	unsigned long nr_applied;
 	unsigned long sz_applied;
-	unsigned long sz_filtered_out;
+	unsigned long sz_ops_filter_passed;
 	unsigned long qt_exceeds;
 };
 
@@ -406,7 +405,7 @@ struct damos;
 struct damos_walk_control {
 	void (*walk_fn)(void *data, struct damon_ctx *ctx,
 			struct damon_target *t, struct damon_region *r,
-			struct damos *s, unsigned long sz_filtered_out);
+			struct damos *s, unsigned long sz_filter_passed);
 	void *data;
 /* private: internal use only */
 	/* informs if the kdamond finished handling of the walk request */
@@ -590,7 +589,7 @@ struct damon_operations {
 			struct damos *scheme);
 	unsigned long (*apply_scheme)(struct damon_ctx *context,
 			struct damon_target *t, struct damon_region *r,
-			struct damos *scheme, unsigned long *filtered_out);
+			struct damos *scheme, unsigned long *sz_filter_passed);
 	bool (*target_valid)(struct damon_target *t);
 	void (*cleanup)(struct damon_ctx *context);
 };
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 32dc83552cc0..59af9a111489 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -1384,14 +1384,14 @@ static bool damos_skip_charged_region(struct damon_target *t,
 
 static void damos_update_stat(struct damos *s,
 		unsigned long sz_tried, unsigned long sz_applied,
-		unsigned long sz_ops_filtered_out)
+		unsigned long sz_ops_filter_passed)
 {
 	s->stat.nr_tried++;
 	s->stat.sz_tried += sz_tried;
 	if (sz_applied)
 		s->stat.nr_applied++;
 	s->stat.sz_applied += sz_applied;
-	s->stat.sz_filtered_out += sz_ops_filtered_out;
+	s->stat.sz_ops_filter_passed += sz_ops_filter_passed;
 }
 
 static bool __damos_filter_out(struct damon_ctx *ctx, struct damon_target *t,
@@ -1467,7 +1467,7 @@ static bool damos_filter_out(struct damon_ctx *ctx, struct damon_target *t,
  */
 static void damos_walk_call_walk(struct damon_ctx *ctx, struct damon_target *t,
 		struct damon_region *r, struct damos *s,
-		unsigned long sz_filtered_out)
+		unsigned long sz_filter_passed)
 {
 	struct damos_walk_control *control;
 
@@ -1476,7 +1476,7 @@ static void damos_walk_call_walk(struct damon_ctx *ctx, struct damon_target *t,
 	mutex_unlock(&ctx->walk_control_lock);
 	if (!control)
 		return;
-	control->walk_fn(control->data, ctx, t, r, s, sz_filtered_out);
+	control->walk_fn(control->data, ctx, t, r, s, sz_filter_passed);
 }
 
 /*
diff --git a/mm/damon/paddr.c b/mm/damon/paddr.c
index 706869adc070..0d97b9132317 100644
--- a/mm/damon/paddr.c
+++ b/mm/damon/paddr.c
@@ -247,7 +247,7 @@ static bool damos_pa_filter_out(struct damos *scheme, struct folio *folio)
 }
 
 static unsigned long damon_pa_pageout(struct damon_region *r, struct damos *s,
-		unsigned long *sz_filtered_out)
+		unsigned long *sz_filter_passed)
 {
 	unsigned long addr, applied;
 	LIST_HEAD(folio_list);
@@ -274,10 +274,10 @@ static unsigned long damon_pa_pageout(struct damon_region *r, struct damos *s,
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio)) {
-			*sz_filtered_out += folio_size(folio);
+		if (damos_pa_filter_out(s, folio))
 			goto put_folio;
-		}
+		else
+			*sz_filter_passed += folio_size(folio);
 
 		folio_clear_referenced(folio);
 		folio_test_clear_young(folio);
@@ -299,7 +299,7 @@ static unsigned long damon_pa_pageout(struct damon_region *r, struct damos *s,
 
 static inline unsigned long damon_pa_mark_accessed_or_deactivate(
 		struct damon_region *r, struct damos *s, bool mark_accessed,
-		unsigned long *sz_filtered_out)
+		unsigned long *sz_filter_passed)
 {
 	unsigned long addr, applied = 0;
 
@@ -309,10 +309,10 @@ static inline unsigned long damon_pa_mark_accessed_or_deactivate(
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio)) {
-			*sz_filtered_out += folio_size(folio);
+		if (damos_pa_filter_out(s, folio))
 			goto put_folio;
-		}
+		else
+			*sz_filter_passed += folio_size(folio);
 
 		if (mark_accessed)
 			folio_mark_accessed(folio);
@@ -326,17 +326,17 @@ static inline unsigned long damon_pa_mark_accessed_or_deactivate(
 }
 
 static unsigned long damon_pa_mark_accessed(struct damon_region *r,
-	struct damos *s, unsigned long *sz_filtered_out)
+	struct damos *s, unsigned long *sz_filter_passed)
 {
 	return damon_pa_mark_accessed_or_deactivate(r, s, true,
-			sz_filtered_out);
+			sz_filter_passed);
 }
 
 static unsigned long damon_pa_deactivate_pages(struct damon_region *r,
-	struct damos *s, unsigned long *sz_filtered_out)
+	struct damos *s, unsigned long *sz_filter_passed)
 {
 	return damon_pa_mark_accessed_or_deactivate(r, s, false,
-			sz_filtered_out);
+			sz_filter_passed);
 }
 
 static unsigned int __damon_pa_migrate_folio_list(
@@ -461,7 +461,7 @@ static unsigned long damon_pa_migrate_pages(struct list_head *folio_list,
 }
 
 static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s,
-		unsigned long *sz_filtered_out)
+		unsigned long *sz_filter_passed)
 {
 	unsigned long addr, applied;
 	LIST_HEAD(folio_list);
@@ -472,10 +472,10 @@ static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s,
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio)) {
-			*sz_filtered_out += folio_size(folio);
+		if (damos_pa_filter_out(s, folio))
 			goto put_folio;
-		}
+		else
+			*sz_filter_passed += folio_size(folio);
 
 		if (!folio_isolate_lru(folio))
 			goto put_folio;
@@ -489,7 +489,7 @@ static unsigned long damon_pa_migrate(struct damon_region *r, struct damos *s,
 }
 
 static unsigned long damon_pa_stat_full(struct damon_region *r, struct damos *s,
-		unsigned long *sz_filtered_out)
+		unsigned long *sz_filter_passed)
 {
 	unsigned long addr, applied = 0;
 	LIST_HEAD(folio_list);
@@ -500,10 +500,10 @@ static unsigned long damon_pa_stat_full(struct damon_region *r, struct damos *s,
 		if (!folio)
 			continue;
 
-		if (damos_pa_filter_out(s, folio)) {
-			*sz_filtered_out += folio_size(folio);
+		if (damos_pa_filter_out(s, folio))
 			goto put_folio;
-		}
+		else
+			*sz_filter_passed += folio_size(folio);
 		applied += folio_size(folio);
 put_folio:
 		folio_put(folio);
@@ -578,7 +578,7 @@ static int damon_pa_alloc(unsigned long pfn, struct damos *scheme)
 /* Preempt or yield memory regions from system */
 static unsigned long damon_pa_alloc_or_free(
 		struct damon_region *r, struct damos *s, bool alloc,
-		unsigned long *sz_filtered_out)
+		unsigned long *sz_filter_passed)
 {
 	unsigned long pfn;
 	unsigned long applied = 0;
@@ -601,28 +601,30 @@ static unsigned long damon_pa_alloc_or_free(
 
 static unsigned long damon_pa_apply_scheme(struct damon_ctx *ctx,
 		struct damon_target *t, struct damon_region *r,
-		struct damos *scheme, unsigned long *filtered_out)
+		struct damos *scheme, unsigned long *sz_filter_passed)
 {
 	switch (scheme->action) {
 	case DAMOS_PAGEOUT:
-		return damon_pa_pageout(r, scheme, filtered_out);
+		return damon_pa_pageout(r, scheme, sz_filter_passed);
 	case DAMOS_LRU_PRIO:
-		return damon_pa_mark_accessed(r, scheme, filtered_out);
+		return damon_pa_mark_accessed(r, scheme, sz_filter_passed);
 	case DAMOS_LRU_DEPRIO:
-		return damon_pa_deactivate_pages(r, scheme, filtered_out);
+		return damon_pa_deactivate_pages(r, scheme, sz_filter_passed);
 	case DAMOS_MIGRATE_HOT:
 	case DAMOS_MIGRATE_COLD:
-		return damon_pa_migrate(r, scheme, filtered_out);
+		return damon_pa_migrate(r, scheme, sz_filter_passed);
 #ifdef CONFIG_ACMA
 	case DAMOS_ALLOC:
-		return damon_pa_alloc_or_free(r, scheme, true, filtered_out);
+		return damon_pa_alloc_or_free(r, scheme, true,
+				sz_filter_passed);
 	case DAMOS_FREE:
-		return damon_pa_alloc_or_free(r, scheme, false, filtered_out);
+		return damon_pa_alloc_or_free(r, scheme, false,
+				sz_filter_passed);
 #endif
 	case DAMOS_STAT:
 		break;
 	case DAMOS_STAT_FULL:
-		return damon_pa_stat_full(r, scheme, filtered_out);
+		return damon_pa_stat_full(r, scheme, sz_filter_passed);
 	default:
 		/* DAMOS actions that not yet supported by 'paddr'. */
 		break;
diff --git a/mm/damon/sysfs-common.h b/mm/damon/sysfs-common.h
index adb209c7c32b..70d84bdc9f5f 100644
--- a/mm/damon/sysfs-common.h
+++ b/mm/damon/sysfs-common.h
@@ -48,7 +48,7 @@ void damon_sysfs_schemes_update_stats(
 void damos_sysfs_populate_region_dir(struct damon_sysfs_schemes *sysfs_schemes,
 		struct damon_ctx *ctx, struct damon_target *t,
 		struct damon_region *r, struct damos *s,
-		bool total_bytes_only, unsigned long sz_filtered_out);
+		bool total_bytes_only, unsigned long sz_filter_passed);
 
 int damon_sysfs_schemes_clear_regions(
 		struct damon_sysfs_schemes *sysfs_schemes);
diff --git a/mm/damon/sysfs-schemes.c b/mm/damon/sysfs-schemes.c
index 8638026b6d10..86826ea4e143 100644
--- a/mm/damon/sysfs-schemes.c
+++ b/mm/damon/sysfs-schemes.c
@@ -19,7 +19,7 @@ struct damon_sysfs_scheme_region {
 	struct damon_addr_range ar;
 	unsigned int nr_accesses;
 	unsigned int age;
-	unsigned long sz_filtered_out;
+	unsigned long sz_filter_passed;
 	struct list_head list;
 };
 
@@ -75,13 +75,13 @@ static ssize_t age_show(struct kobject *kobj, struct kobj_attribute *attr,
 	return sysfs_emit(buf, "%u\n", region->age);
 }
 
-static ssize_t filtered_out_bytes_show(struct kobject *kobj,
+static ssize_t sz_filter_passed_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
 	struct damon_sysfs_scheme_region *region = container_of(kobj,
 			struct damon_sysfs_scheme_region, kobj);
 
-	return sysfs_emit(buf, "%lu\n", region->sz_filtered_out);
+	return sysfs_emit(buf, "%lu\n", region->sz_filter_passed);
 }
 
 static void damon_sysfs_scheme_region_release(struct kobject *kobj)
@@ -105,15 +105,15 @@ static struct kobj_attribute damon_sysfs_scheme_region_nr_accesses_attr =
 static struct kobj_attribute damon_sysfs_scheme_region_age_attr =
 		__ATTR_RO_MODE(age, 0400);
 
-static struct kobj_attribute damon_sysfs_scheme_region_filtered_out_bytes_attr =
-		__ATTR_RO_MODE(filtered_out_bytes, 0400);
+static struct kobj_attribute damon_sysfs_scheme_region_sz_filter_passed_attr =
+		__ATTR_RO_MODE(sz_filter_passed, 0400);
 
 static struct attribute *damon_sysfs_scheme_region_attrs[] = {
 	&damon_sysfs_scheme_region_start_attr.attr,
 	&damon_sysfs_scheme_region_end_attr.attr,
 	&damon_sysfs_scheme_region_nr_accesses_attr.attr,
 	&damon_sysfs_scheme_region_age_attr.attr,
-	&damon_sysfs_scheme_region_filtered_out_bytes_attr.attr,
+	&damon_sysfs_scheme_region_sz_filter_passed_attr.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(damon_sysfs_scheme_region);
@@ -202,7 +202,7 @@ struct damon_sysfs_stats {
 	unsigned long sz_tried;
 	unsigned long nr_applied;
 	unsigned long sz_applied;
-	unsigned long sz_filtered_out;
+	unsigned long sz_ops_filter_passed;
 	unsigned long qt_exceeds;
 };
 
@@ -247,13 +247,13 @@ static ssize_t sz_applied_show(struct kobject *kobj,
 	return sysfs_emit(buf, "%lu\n", stats->sz_applied);
 }
 
-static ssize_t sz_filtered_out_show(struct kobject *kobj,
+static ssize_t sz_ops_filter_passed_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
 	struct damon_sysfs_stats *stats = container_of(kobj,
 			struct damon_sysfs_stats, kobj);
 
-	return sysfs_emit(buf, "%lu\n", stats->sz_filtered_out);
+	return sysfs_emit(buf, "%lu\n", stats->sz_ops_filter_passed);
 }
 
 static ssize_t qt_exceeds_show(struct kobject *kobj,
@@ -282,8 +282,8 @@ static struct kobj_attribute damon_sysfs_stats_nr_applied_attr =
 static struct kobj_attribute damon_sysfs_stats_sz_applied_attr =
 		__ATTR_RO_MODE(sz_applied, 0400);
 
-static struct kobj_attribute damon_sysfs_stats_sz_filtered_out_attr =
-		__ATTR_RO_MODE(sz_filtered_out, 0400);
+static struct kobj_attribute damon_sysfs_stats_sz_ops_filter_passed_attr =
+		__ATTR_RO_MODE(sz_ops_filter_passed, 0400);
 
 static struct kobj_attribute damon_sysfs_stats_qt_exceeds_attr =
 		__ATTR_RO_MODE(qt_exceeds, 0400);
@@ -293,7 +293,7 @@ static struct attribute *damon_sysfs_stats_attrs[] = {
 	&damon_sysfs_stats_sz_tried_attr.attr,
 	&damon_sysfs_stats_nr_applied_attr.attr,
 	&damon_sysfs_stats_sz_applied_attr.attr,
-	&damon_sysfs_stats_sz_filtered_out_attr.attr,
+	&damon_sysfs_stats_sz_ops_filter_passed_attr.attr,
 	&damon_sysfs_stats_qt_exceeds_attr.attr,
 	NULL,
 };
@@ -2111,7 +2111,8 @@ void damon_sysfs_schemes_update_stats(
 		sysfs_stats->sz_tried = scheme->stat.sz_tried;
 		sysfs_stats->nr_applied = scheme->stat.nr_applied;
 		sysfs_stats->sz_applied = scheme->stat.sz_applied;
-		sysfs_stats->sz_filtered_out = scheme->stat.sz_filtered_out;
+		sysfs_stats->sz_ops_filter_passed =
+			scheme->stat.sz_ops_filter_passed;
 		sysfs_stats->qt_exceeds = scheme->stat.qt_exceeds;
 	}
 }
@@ -2130,7 +2131,7 @@ void damon_sysfs_schemes_update_stats(
 void damos_sysfs_populate_region_dir(struct damon_sysfs_schemes *sysfs_schemes,
 		struct damon_ctx *ctx, struct damon_target *t,
 		struct damon_region *r, struct damos *s, bool total_bytes_only,
-		unsigned long sz_filtered_out)
+		unsigned long sz_filter_passed)
 {
 	struct damos *scheme;
 	struct damon_sysfs_scheme_regions *sysfs_regions;
@@ -2155,7 +2156,7 @@ void damos_sysfs_populate_region_dir(struct damon_sysfs_schemes *sysfs_schemes,
 	region = damon_sysfs_scheme_region_alloc(r);
 	if (!region)
 		return;
-	region->sz_filtered_out = sz_filtered_out;
+	region->sz_filter_passed = sz_filter_passed;
 	list_add_tail(&region->list, &sysfs_regions->regions_list);
 	sysfs_regions->nr_regions++;
 	if (kobject_init_and_add(&region->kobj,
diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index ff7a88de8145..7b9cd2868d41 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -1462,14 +1462,15 @@ struct damon_sysfs_schemes_walk_data {
 /* populate the region directory */
 static void damon_sysfs_schemes_tried_regions_upd_one(void *data, struct damon_ctx *ctx,
 		struct damon_target *t, struct damon_region *r,
-		struct damos *s, unsigned long sz_filtered_out)
+		struct damos *s, unsigned long sz_filter_passed)
 {
 	struct damon_sysfs_schemes_walk_data *walk_data = data;
 	struct damon_sysfs_kdamond *sysfs_kdamond = walk_data->sysfs_kdamond;
 
 	damos_sysfs_populate_region_dir(
 			sysfs_kdamond->contexts->contexts_arr[0]->schemes,
-			ctx, t, r, s, walk_data->total_bytes_only, sz_filtered_out);
+			ctx, t, r, s, walk_data->total_bytes_only,
+			sz_filter_passed);
 }
 
 static int damon_sysfs_update_schemes_tried_regions(
diff --git a/mm/damon/vaddr.c b/mm/damon/vaddr.c
index 4c371efc0eb0..a6174f725bd7 100644
--- a/mm/damon/vaddr.c
+++ b/mm/damon/vaddr.c
@@ -655,7 +655,7 @@ static unsigned long damos_madvise(struct damon_target *target,
 
 static unsigned long damon_va_apply_scheme(struct damon_ctx *ctx,
 		struct damon_target *t, struct damon_region *r,
-		struct damos *scheme, unsigned long *filtered_out)
+		struct damos *scheme, unsigned long *sz_filter_passed)
 {
 	int madv_action;
 
-- 
2.39.5

