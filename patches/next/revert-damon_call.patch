From: SeongJae Park <sj@kernel.org>
Date: Fri, 22 Nov 2024 14:52:20 -0800
Subject: [PATCH] revert damon_call

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 include/linux/damon.h | 24 -----------------
 mm/damon/core.c       | 63 -------------------------------------------
 2 files changed, 87 deletions(-)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index 0a8a5cfe84de..e8d53c0638b6 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -579,24 +579,6 @@ struct damon_callback {
 	void (*before_terminate)(struct damon_ctx *context);
 };
 
-/*
- * struct damon_call_control - Control DAMON worker thread callback.
- *
- * @fn:			Function to be called back from DAMON.
- * @arg:		Argument that will be passed to @fn.
- * @return_code:	Return code from @fn.
- */
-struct damon_call_control {
-	int (*fn)(void *arg);
-	void *arg;
-	int return_code;
-/* private: internal use only */
-	/* for waiting on DAMON's @fn invocation completion. */
-	struct completion completion;
-	/* for saving if the request is canceled. */
-	bool canceled;
-};
-
 /**
  * struct damon_attrs - Monitoring attributes for accuracy/overhead control.
  *
@@ -677,10 +659,6 @@ struct damon_ctx {
 	/* for scheme quotas prioritization */
 	unsigned long *regions_score_histogram;
 
-	/* for damon_call() */
-	struct damon_call_control *call_control;
-	struct mutex call_control_lock;
-
 /* public: */
 	struct task_struct *kdamond;
 	struct mutex kdamond_lock;
@@ -828,8 +806,6 @@ static inline unsigned int damon_max_nr_accesses(const struct damon_attrs *attrs
 int damon_start(struct damon_ctx **ctxs, int nr_ctxs, bool exclusive);
 int damon_stop(struct damon_ctx **ctxs, int nr_ctxs);
 
-int damon_call(struct damon_ctx *ctx, struct damon_call_control *control);
-
 int damon_set_region_biggest_system_ram_default(struct damon_target *t,
 				unsigned long *start, unsigned long *end);
 
diff --git a/mm/damon/core.c b/mm/damon/core.c
index 24649b9d7db5..d2eeebca964d 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -533,7 +533,6 @@ struct damon_ctx *damon_new_ctx(void)
 	ctx->next_ops_update_sis = 0;
 
 	mutex_init(&ctx->kdamond_lock);
-	mutex_init(&ctx->call_control_lock);
 
 	ctx->attrs.min_nr_regions = 10;
 	ctx->attrs.max_nr_regions = 1000;
@@ -1194,42 +1193,6 @@ static bool damon_is_running(struct damon_ctx *ctx)
 	return running;
 }
 
-/**
- * damon_call() - Invoke a given function on a DAMON worker thread.
- * @ctx:	DAMON context to execute the function for.
- * @control:	Structure saving call request and result.
- *
- * Ask DAMON worker thread of @ctx to call a given function as specified in
- * @control and wait for the result.  The function can hence safely access the
- * internal data of &struct damon_ctx including &struct damon_region objects
- * without additional locking.  The return code of the callback function will
- * be saved in &->return_code of @control.
-
- * If DAMON is deactivated by watermarks or terminated before the function is
- * called back, the request is canceled.
- *
- * Return: 0 on success, negative error code otherwise.
- */
-int damon_call(struct damon_ctx *ctx, struct damon_call_control *control)
-{
-	init_completion(&control->completion);
-	control->canceled = false;
-
-	mutex_lock(&ctx->call_control_lock);
-	if (ctx->call_control) {
-		mutex_unlock(&ctx->call_control_lock);
-		return -EBUSY;
-	}
-	ctx->call_control = control;
-	mutex_unlock(&ctx->call_control_lock);
-	if (!damon_is_running(ctx))
-		return -EINVAL;
-	wait_for_completion(&control->completion);
-	if (control->canceled)
-		return -ECANCELED;
-	return 0;
-}
-
 /*
  * Reset the aggregated monitoring results ('nr_accesses' of each region).
  */
@@ -2021,28 +1984,6 @@ static void kdamond_usleep(unsigned long usecs)
 		usleep_idle_range(usecs, usecs + 1);
 }
 
-static void kdamond_callback(struct damon_ctx *ctx, bool cancel)
-{
-	struct damon_call_control *control;
-	int ret = 0;
-
-	mutex_lock(&ctx->call_control_lock);
-	control = ctx->call_control;
-	mutex_unlock(&ctx->call_control_lock);
-	if (!control)
-		return;
-	if (cancel) {
-		control->canceled = true;
-	} else {
-		ret = control->fn(control->arg);
-		control->return_code = ret;
-	}
-	complete(&control->completion);
-	mutex_lock(&ctx->call_control_lock);
-	ctx->call_control = NULL;
-	mutex_unlock(&ctx->call_control_lock);
-}
-
 /* Returns negative error code if it's not activated but should return */
 static int kdamond_wait_activation(struct damon_ctx *ctx)
 {
@@ -2067,7 +2008,6 @@ static int kdamond_wait_activation(struct damon_ctx *ctx)
 		if (ctx->callback.after_wmarks_check &&
 				ctx->callback.after_wmarks_check(ctx))
 			break;
-		kdamond_callback(ctx, true);
 	}
 	return -EBUSY;
 }
@@ -2137,7 +2077,6 @@ static int kdamond_fn(void *data)
 		if (ctx->callback.after_sampling &&
 				ctx->callback.after_sampling(ctx))
 			break;
-		kdamond_callback(ctx, false);
 
 		kdamond_usleep(sample_interval);
 		ctx->passed_sample_intervals++;
@@ -2199,8 +2138,6 @@ static int kdamond_fn(void *data)
 	ctx->kdamond = NULL;
 	mutex_unlock(&ctx->kdamond_lock);
 
-	kdamond_callback(ctx, true);
-
 	mutex_lock(&damon_lock);
 	nr_running_ctxs--;
 	if (!nr_running_ctxs && running_exclusive_ctxs)
-- 
2.39.5

