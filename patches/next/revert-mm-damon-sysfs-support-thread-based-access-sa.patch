From: SeongJae Park <sj@kernel.org>
Date: Tue, 2 Dec 2025 21:19:33 -0800
Subject: [PATCH] revert "mm/damon/sysfs: support thread based access sample
 filtering"

Signed-off-by: SeongJae Park <sj@kernel.org>
---
 mm/damon/sysfs.c | 75 ------------------------------------------------
 1 file changed, 75 deletions(-)

diff --git a/mm/damon/sysfs.c b/mm/damon/sysfs.c
index b96df2d2d17e..3aac2aea6b0c 100644
--- a/mm/damon/sysfs.c
+++ b/mm/damon/sysfs.c
@@ -759,7 +759,6 @@ struct damon_sysfs_sample_filter {
 	bool matching;
 	bool allow;
 	cpumask_t cpumask;
-	int *tid_arr;	/* first entry is the length of the array */
 };
 
 static struct damon_sysfs_sample_filter *damon_sysfs_sample_filter_alloc(void)
@@ -778,10 +777,6 @@ damon_sysfs_sample_filter_type_names[] = {
 		.type = DAMON_FILTER_TYPE_CPUMASK,
 		.name = "cpumask",
 	},
-	{
-		.type = DAMON_FILTER_TYPE_THREADS,
-		.name = "threads",
-	},
 };
 
 static ssize_t type_show(struct kobject *kobj,
@@ -893,47 +888,6 @@ static ssize_t cpumask_store(struct kobject *kobj, struct kobj_attribute *attr,
 	return count;
 }
 
-static ssize_t tid_arr_show(struct kobject *kobj, struct kobj_attribute *attr,
-		char *buf)
-{
-	struct damon_sysfs_sample_filter *sample_filter = container_of(kobj,
-			struct damon_sysfs_sample_filter, kobj);
-	char *str;
-	int nr_tids, *tid_arr;
-	int i, ret;
-
-	if (!sample_filter->tid_arr)
-		return sysfs_emit(buf, "\n");
-
-	str = kcalloc(2048, sizeof(*str), GFP_KERNEL);
-	if (!str)
-		return -ENOMEM;
-	nr_tids = sample_filter->tid_arr[0];
-	tid_arr = &sample_filter->tid_arr[1];
-	for (i = 0; i < nr_tids; i++) {
-		snprintf(&str[strlen(str)], 2048 - strlen(str), "%d",
-				tid_arr[i]);
-		if (i < nr_tids - 1)
-			snprintf(&str[strlen(str)], 2048 - strlen(str), ",");
-	}
-	ret = sysfs_emit(buf, "%s\n", str);
-	kfree(str);
-	return ret;
-}
-
-static ssize_t tid_arr_store(struct kobject *kobj, struct kobj_attribute *attr,
-		const char *buf, size_t count)
-{
-	struct damon_sysfs_sample_filter *sample_filter = container_of(kobj,
-			struct damon_sysfs_sample_filter, kobj);
-	int err;
-
-	err = parse_int_array(buf, count, &sample_filter->tid_arr);
-	if (err)
-		return err;
-	return count;
-}
-
 static void damon_sysfs_sample_filter_release(struct kobject *kobj)
 {
 	struct damon_sysfs_sample_filter *filter = container_of(kobj,
@@ -954,15 +908,11 @@ static struct kobj_attribute damon_sysfs_sample_filter_allow_attr =
 static struct kobj_attribute damon_sysfs_sample_filter_cpumask_attr =
 		__ATTR_RW_MODE(cpumask, 0600);
 
-static struct kobj_attribute damon_sysfs_sample_filter_tid_arr_attr =
-		__ATTR_RW_MODE(tid_arr, 0600);
-
 static struct attribute *damon_sysfs_sample_filter_attrs[] = {
 	&damon_sysfs_sample_filter_type_attr.attr,
 	&damon_sysfs_sample_filter_matching_attr.attr,
 	&damon_sysfs_sample_filter_allow_attr.attr,
 	&damon_sysfs_sample_filter_cpumask_attr.attr,
-	&damon_sysfs_sample_filter_tid_arr_attr.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(damon_sysfs_sample_filter);
@@ -2002,25 +1952,6 @@ static inline bool damon_sysfs_kdamond_running(
 		damon_is_running(kdamond->damon_ctx);
 }
 
-static int damon_sysfs_set_threads_filter(struct damon_sample_filter *filter,
-		int *sysfs_tid_arr)
-{
-	int nr_tids, i;
-	pid_t *tid_arr;
-
-	if (!sysfs_tid_arr)
-		return -EINVAL;
-	nr_tids = sysfs_tid_arr[0];
-	tid_arr = kmalloc_array(nr_tids, sizeof(*tid_arr), GFP_KERNEL);
-	if (!tid_arr)
-		return -ENOMEM;
-	for (i = 0; i < nr_tids; i++)
-		tid_arr[i] = sysfs_tid_arr[i + 1];
-	filter->tid_arr = tid_arr;
-	filter->nr_tids = nr_tids;
-	return 0;
-}
-
 static int damon_sysfs_set_sample_filters(
 		struct damon_sample_control *control,
 		struct damon_sysfs_sample_filters *sysfs_filters)
@@ -2041,12 +1972,6 @@ static int damon_sysfs_set_sample_filters(
 		case DAMON_FILTER_TYPE_CPUMASK:
 			filter->cpumask = sysfs_filter->cpumask;
 			break;
-		case DAMON_FILTER_TYPE_THREADS:
-			err = damon_sysfs_set_threads_filter(filter,
-					sysfs_filter->tid_arr);
-			if (err)
-				damon_free_sample_filter(filter);
-			break;
 		default:
 			break;
 		}
-- 
2.47.3

