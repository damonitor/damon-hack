From hackermail Thu Jan  1 00:00:00 1970
From: SeongJae Park <sj@kernel.org>
Cc: SeongJae Park <sj@kernel.org>, Andrew Morton <akpm@linux-foundation.org>, damon@lists.linux.dev, kernel-team@meta.com, linux-kernel@vger.kernel.org, linux-mm@kvack.org
Message-Id: <20250912023946.62337-2-sj@kernel.org>
In-Reply-To: <20250912023946.62337-1-sj@kernel.org>
Date: Thu, 11 Sep 2025 19:39:40 -0700
Subject: [RFC PATCH 1/7] mm/damon/core: implement damon_initialized() function

If DAMON is tried to be used when it is not yet successfully
initialized, the caller could be crashed.  DAMON core layer is not
providing a reliable way to see if it is successfully initialized and
therefore ready to be used, though.  As a result, DAMON API callers are
implementing their own hacks to see it.  The hacks simply assume DAMON
should be ready on module init time.  It is not reliable as DAMON
initialization can indeed fail if KMEM_CACHE() fails, and difficult to
maintain as those are duplicates.  Implement a core layer API function
for better reliability and maintainability to replace the hacks with
followup commits.

Signed-off-by: SeongJae Park <sj@kernel.org>
Link: https://patch.msgid.link/20250912023946.62337-2-sj@kernel.org
Cc: Andrew Morton <akpm@linux-foundation.org>
---
 include/linux/damon.h |  1 +
 mm/damon/core.c       | 10 ++++++++++
 2 files changed, 11 insertions(+)

diff --git a/include/linux/damon.h b/include/linux/damon.h
index 484b0558f426..0f012b1e39fa 100644
--- a/include/linux/damon.h
+++ b/include/linux/damon.h
@@ -941,6 +941,7 @@ static inline unsigned int damon_max_nr_accesses(const struct damon_attrs *attrs
 }
 
 
+bool damon_initialized(void);
 int damon_start(struct damon_ctx **ctxs, int nr_ctxs, bool exclusive);
 int damon_stop(struct damon_ctx **ctxs, int nr_ctxs);
 bool damon_is_running(struct damon_ctx *ctx);
diff --git a/mm/damon/core.c b/mm/damon/core.c
index f32034973cc1..38ff417f4eb9 100644
--- a/mm/damon/core.c
+++ b/mm/damon/core.c
@@ -2880,6 +2880,16 @@ void damon_update_region_access_rate(struct damon_region *r, bool accessed,
 		r->nr_accesses++;
 }
 
+/**
+ * damon_initialized() - Return if DAMON is ready to be used.
+ *
+ * Return: true if DAMON is ready to be used, false otherwise.
+ */
+bool damon_initialized(void)
+{
+	return damon_region_cache != NULL;
+}
+
 static int __init damon_init(void)
 {
 	damon_region_cache = KMEM_CACHE(damon_region, 0);
-- 
2.39.5